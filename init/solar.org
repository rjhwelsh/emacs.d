#+TITLE: Sunrise/Sunset functions
#+AUTHOR: Roger J. H. Welsh
#+EMAIL: rjhwelsh@posteo.net
#+PROPERTY: header-args    :results silent

These functions have been taken from.
https://stackoverflow.com/questions/22889036/custom-diary-sunrise-function-not-working-autoload-diary-emacs
Credit to Brady Trainor.

These functions build on solar.el
#+begin_src emacs-lisp
(require 'solar)
#+end_src

* Sunrise
	#+begin_src emacs-lisp
	(defun solar-sunrise-string (date &optional nolocation)
  "String of *local* time of sunrise and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s (%s hours daylight)"
     (if (car l)
     (concat (apply 'solar-time-string (car l)) " Sunrise")
       "no sunrise")
     (nth 2 l)
     )))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunrise ()
  "Local time of sunrise as a diary entry.
  Accurate to a few seconds."
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunrise-string date))
	#+end_src

* Sunset
	#+begin_src emacs-lisp
	(defun solar-sunset-string (date &optional nolocation)
  "String of *local* time of sunset and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s (%s hours daylight)"
     (if (cadr l)
     (concat (apply 'solar-time-string (cadr l)) " Sunset" )
       "no sunset")
     (nth 2 l)
     )))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunset ()
  "Local time of sunset as a diary entry.
  Accurate to a few seconds."
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunset-string date))
	#+end_src

* Patch :org:org:agenda:
Add a patch to allow times to be defined with sexp-expressions.
Time is defined in the string portion returned by the sexp.
The time must be at the start of the string.

** org.el
Define function to obtain time from sexp expressions.
#+begin_src emacs-lisp
	(defun org-timestamp-from-sexp (s d)
		"Convert Org timestamp S, as a sexp-string, into a timestamp object for date D.
				Return nil if S is not a valid timestamp sexp"
    (require 'diary-lib)
		(let (
					(ts
					 (format "%04d"
									 (diary-entry-time
										(diary-sexp-entry s "" d)))
					 ))
			(string-match "\\(..\\)\\(..\\)" ts)
			(concat
			 (match-string 1 ts)
			 ":"
			 (match-string 2 ts))
			)
		)
	(org-timestamp-from-sexp "(diary-sunrise)" (calendar-current-date))
#+end_src

** org-agenda.el
*** +org-agenda-get-sexps+
*** org-agenda-get-scheduled
#+begin_src emacs-lisp
	(defun org-agenda-get-scheduled (&optional deadlines with-hour)
		"Return the scheduled information for agenda display.
	Optional argument DEADLINES is a list of deadline items to be
	displayed in agenda view.  When WITH-HOUR is non-nil, only return
	scheduled items with an hour specification like [h]h:mm."
		(let* ((props (list 'org-not-done-regexp org-not-done-regexp
												'org-todo-regexp org-todo-regexp
												'org-complex-heading-regexp org-complex-heading-regexp
												'done-face 'org-agenda-done
												'mouse-face 'highlight
												'help-echo
												(format "mouse-2 or RET jump to Org file %s"
																(abbreviate-file-name buffer-file-name))))
					 (regexp (if with-hour
											 org-scheduled-time-hour-regexp
										 org-scheduled-time-regexp))
					 (today (org-today))
					 (todayp (org-agenda-today-p date)) ; DATE bound by calendar.
					 (current (calendar-absolute-from-gregorian date))
					 (deadline-pos
						(mapcar (lambda (d)
											(let ((m (get-text-property 0 'org-hd-marker d)))
												(and m (marker-position m))))
										deadlines))
					 scheduled-items)
			(goto-char (point-min))
			(while (re-search-forward regexp nil t)
				(catch :skip
					(unless (save-match-data (org-at-planning-p)) (throw :skip nil))
					(org-agenda-skip)
					(let* ((s (match-string 1))
								 (pos (1- (match-beginning 1)))
								 (todo-state (save-match-data (org-get-todo-state)))
								 (donep (member todo-state org-done-keywords))
								 (sexp? (string-prefix-p "%%" s))
								 ;; SCHEDULE is the scheduled date for the entry.  It is
								 ;; either the bare date or the last repeat, according
								 ;; to `org-agenda-prefer-last-repeat'.
								 (schedule
									(cond
									 (sexp? (org-agenda--timestamp-to-absolute s current))
									 ((or (eq org-agenda-prefer-last-repeat t)
												(member todo-state org-agenda-prefer-last-repeat))
										(org-agenda--timestamp-to-absolute
										 s today 'past (current-buffer) pos))
									 (t (org-agenda--timestamp-to-absolute s))))
								 ;; REPEAT is the future repeat closest from CURRENT,
								 ;; according to `org-agenda-show-future-repeats'. If
								 ;; the latter is nil, or if the time stamp has no
								 ;; repeat part, default to SCHEDULE.
								 (repeat
									(cond
									 (sexp? schedule)
									 ((<= current today) schedule)
									 ((not org-agenda-show-future-repeats) schedule)
									 (t
										(let ((base (if (eq org-agenda-show-future-repeats 'next)
																		(1+ today)
																	current)))
											(org-agenda--timestamp-to-absolute
											 s base 'future (current-buffer) pos)))))
								 (diff (- current schedule))
								 (warntime (get-text-property (point) 'org-appt-warntime))
								 (pastschedp (< schedule today))
								 (futureschedp (> schedule today))
								 (habitp (and (fboundp 'org-is-habit-p) (org-is-habit-p)))
								 (suppress-delay
									(let ((deadline (and org-agenda-skip-scheduled-delay-if-deadline
																			 (org-entry-get nil "DEADLINE"))))
										(cond
										 ((not deadline) nil)
										 ;; The current item has a deadline date, so
										 ;; evaluate its delay time.
										 ((integerp org-agenda-skip-scheduled-delay-if-deadline)
											;; Use global delay time.
											(- org-agenda-skip-scheduled-delay-if-deadline))
										 ((eq org-agenda-skip-scheduled-delay-if-deadline
													'post-deadline)
											;; Set delay to no later than DEADLINE.
											(min (- schedule
															(org-agenda--timestamp-to-absolute deadline))
													 org-scheduled-delay-days))
										 (t 0))))
								 (ddays
									(cond
									 ;; Nullify delay when a repeater triggered already
									 ;; and the delay is of the form --Xd.
									 ((and (string-match-p "--[0-9]+[hdwmy]" s)
												 (> schedule (org-agenda--timestamp-to-absolute s)))
										0)
									 (suppress-delay
										(let ((org-scheduled-delay-days suppress-delay))
											(org-get-wdays s t t)))
									 (t (org-get-wdays s t)))))
						;; Display scheduled items at base date (SCHEDULE), today if
						;; scheduled before the current date, and at any repeat past
						;; today.  However, skip delayed items and items that have
						;; been displayed for more than `org-scheduled-past-days'.
						(unless (and todayp
												 habitp
												 (bound-and-true-p org-habit-show-all-today))
							(when (or (and (> ddays 0) (< diff ddays))
												(> diff (or (and habitp org-habit-scheduled-past-days)
																		org-scheduled-past-days))
												(> schedule current)
												(and (/= current schedule)
														 (/= current today)
														 (/= current repeat)))
								(throw :skip nil)))
						;; Possibly skip done tasks.
						(when (and donep
											 (or org-agenda-skip-scheduled-if-done
													 (/= schedule current)))
							(throw :skip nil))
						;; Skip entry if it already appears as a deadline, per
						;; `org-agenda-skip-scheduled-if-deadline-is-shown'.  This
						;; doesn't apply to habits.
						(when (pcase org-agenda-skip-scheduled-if-deadline-is-shown
										((guard
											(or (not (memq (line-beginning-position 0) deadline-pos))
													habitp))
										 nil)
										(`repeated-after-deadline
										 (let ((deadline (time-to-days
																			(org-get-deadline-time (point)))))
											 (and (<= schedule deadline) (> current deadline))))
										(`not-today pastschedp)
										(`t t)
										(_ nil))
							(throw :skip nil))
						;; Skip habits if `org-habit-show-habits' is nil, or if we
						;; only show them for today.  Also skip done habits.
						(when (and habitp
											 (or donep
													 (not (bound-and-true-p org-habit-show-habits))
													 (and (not todayp)
																(bound-and-true-p
																 org-habit-show-habits-only-for-today))))
							(throw :skip nil))
						(save-excursion
							(re-search-backward "^\\*+[ \t]+" nil t)
							(goto-char (match-end 0))
							(let* ((category (org-get-category))
										 (inherited-tags
											(or (eq org-agenda-show-inherited-tags 'always)
													(and (listp org-agenda-show-inherited-tags)
															 (memq 'agenda org-agenda-show-inherited-tags))
													(and (eq org-agenda-show-inherited-tags t)
															 (or (eq org-agenda-use-tag-inheritance t)
																	 (memq 'agenda
																				 org-agenda-use-tag-inheritance)))))
										 (tags (org-get-tags nil (not inherited-tags)))
										 (level (make-string (org-reduced-level (org-outline-level))
																				 ?\s))
										 (head
											(concat
											 (buffer-substring (point) (line-end-position))
											 " "
											 (if sexp? (org-timestamp-from-sexp (substring s 2)
																													(calendar-gregorian-from-absolute
																													 current))
												 )))

										 (time
											(cond
											 ;; No time of day designation if it is only a
											 ;; reminder, except for habits, which always show
											 ;; the time of day.  Habits are an exception
											 ;; because if there is a time of day, that is
											 ;; interpreted to mean they should usually happen
											 ;; then, even if doing the habit was missed.
											 (sexp?
												(org-timestamp-from-sexp (substring s 2)
																								 (calendar-gregorian-from-absolute
																									current)))
											 ((and
												 (not habitp)
												 (/= current schedule)
												 (/= current repeat))
												nil)
											 ((string-match " \\([012]?[0-9]:[0-9][0-9]\\)" s)
												(concat (substring s (match-beginning 1)) " "))
											 (t 'time)))
										 (item
											(org-agenda-format-item
											 (pcase-let ((`(,first ,past) org-agenda-scheduled-leaders))
												 ;; Show a reminder of a past scheduled today.
												 (if (and todayp pastschedp)
														 (format past diff)
													 first))
											 head level category tags time nil habitp))
										 (face (cond ((and (not habitp) pastschedp)
																	'org-scheduled-previously)
																 ((and habitp futureschedp)
																	'org-agenda-done)
																 (todayp 'org-scheduled-today)
																 (t 'org-scheduled)))
										 (habitp (and habitp (org-habit-parse-todo))))
								(org-add-props item props
									'undone-face face
									'face (if donep 'org-agenda-done face)
									'org-marker (org-agenda-new-marker pos)
									'org-hd-marker (org-agenda-new-marker (line-beginning-position))
									'type (if pastschedp "past-scheduled" "scheduled")
									'date (if pastschedp schedule date)
									'ts-date schedule
									'warntime warntime
									'level level
									'priority (if habitp (org-habit-get-priority habitp)
															(+ 99 diff (org-get-priority item)))
									'org-habit-p habitp
									'todo-state todo-state)
								(push item scheduled-items))))))
			(nreverse scheduled-items)))
#+end_src
*** org-agenda-format-item
#+begin_src emacs-lisp
	(defun org-agenda-format-item (extra txt &optional level category tags dotime
																			 remove-re habitp)
		"Format TXT to be inserted into the agenda buffer.
	In particular, add the prefix and corresponding text properties.

	EXTRA must be a string to replace the `%s' specifier in the prefix format.
	LEVEL may be a string to replace the `%l' specifier.
	CATEGORY (a string, a symbol or nil) may be used to overrule the default
	category taken from local variable or file name.  It will replace the `%c'
	specifier in the format.
	DOTIME, when non-nil, indicates that a time-of-day should be extracted from
	TXT for sorting of this entry, and for the `%t' specifier in the format.
	When DOTIME is a string, this string is searched for a time before TXT is.
	TAGS can be the tags of the headline.
	Any match of REMOVE-RE will be removed from TXT."
		;; We keep the org-prefix-* variable values along with a compiled
		;; formatter, so that multiple agendas existing at the same time do
		;; not step on each other toes.
		;;
		;; It was inconvenient to make these variables buffer local in
		;; Agenda buffers, because this function expects to be called with
		;; the buffer where item comes from being current, and not agenda
		;; buffer
		(let* ((bindings (car org-prefix-format-compiled))
					 (formatter (cadr org-prefix-format-compiled)))
			(cl-loop for (var value) in bindings
							 do (set var value))
			(save-match-data
				;; Diary entries sometimes have extra whitespace at the beginning
				(setq txt (org-trim txt))

				;; Fix the tags part in txt
				(setq txt (org-agenda-fix-displayed-tags
									 txt tags
									 org-agenda-show-inherited-tags
									 org-agenda-hide-tags-regexp))

				(let* ((category (or category
														 (if buffer-file-name
																 (file-name-sans-extension
																	(file-name-nondirectory buffer-file-name))
															 "")))
							 (category-icon (org-agenda-get-category-icon category))
							 (category-icon (if category-icon
																	(propertize " " 'display category-icon)
																""))
							 (effort (and (not (string= txt ""))
														(get-text-property 1 'effort txt)))
							 ;; time, tag, effort are needed for the eval of the prefix format
							 (tag (if tags (nth (1- (length tags)) tags) ""))
							 (time-grid-trailing-characters (nth 2 org-agenda-time-grid))
							 time
							 (ts (when dotime (concat
																 (if (stringp dotime) dotime "")
																 (and org-agenda-search-headline-for-time txt))))
							 (time-of-day (and dotime (org-get-time-of-day ts)))
							 stamp plain s0 s1 s2 rtn srp l
							 duration breadcrumbs)
					(and (derived-mode-p 'org-mode) buffer-file-name
							 (add-to-list 'org-agenda-contributing-files buffer-file-name))
					(when (and dotime time-of-day)
						;; Extract starting and ending time and move them to prefix
						(when (or (setq stamp (string-match org-stamp-time-of-day-regexp ts))
											(setq plain (string-match org-plain-time-of-day-regexp ts)))
							(setq s0 (match-string 0 ts)
										srp (and stamp (match-end 3))
										s1 (match-string (if plain 1 2) ts)
										s2 (match-string (if plain 8 (if srp 4 6)) ts))

							;; If the times are in TXT (not in DOTIMES), and the prefix will list
							;; them, we might want to remove them there to avoid duplication.
							;; The user can turn this off with a variable.
							(when (and org-prefix-has-time
												 org-agenda-remove-times-when-in-prefix (or stamp plain)
												 (string-match (concat (regexp-quote s0) " *") txt)
												 (not (equal ?\] (string-to-char (substring txt (match-end 0)))))
												 (if (eq org-agenda-remove-times-when-in-prefix 'beg)
														 (= (match-beginning 0) 0)
													 t))
								(setq txt (replace-match "" nil nil txt))))
						;; Normalize the time(s) to 24 hour
						(when s1 (setq s1 (org-get-time-of-day s1 'string t)))
						(when s2 (setq s2 (org-get-time-of-day s2 'string t)))

						;; Try to set s2 if s1 and
						;; `org-agenda-default-appointment-duration' are set
						(when (and s1 (not s2) org-agenda-default-appointment-duration)
							(setq s2
										(org-duration-from-minutes
										 (+ (org-duration-to-minutes s1 t)
												org-agenda-default-appointment-duration)
										 nil t)))

						;; Compute the duration
						(when s2
							(setq duration (- (org-duration-to-minutes s2)
																(org-duration-to-minutes s1)))))

					(when (string-match org-tag-group-re txt)
						;; Tags are in the string
						(if (or (eq org-agenda-remove-tags t)
										(and org-agenda-remove-tags
												 org-prefix-has-tag))
								(setq txt (replace-match "" t t txt))
							(setq txt (replace-match
												 (concat (make-string (max (- 50 (length txt)) 1) ?\ )
																 (match-string 1 txt))
												 t t txt))))

					(when remove-re
						(while (string-match remove-re txt)
							(setq txt (replace-match "" t t txt))))

					;; Set org-heading property on `txt' to mark the start of the
					;; heading.
					(add-text-properties 0 (length txt) '(org-heading t) txt)

					;; Prepare the variables needed in the eval of the compiled format
					(when org-prefix-has-breadcrumbs
						(setq breadcrumbs (org-with-point-at (org-get-at-bol 'org-marker)
																(let ((s (org-format-outline-path (org-get-outline-path)
																																	(1- (frame-width))
																																	nil org-agenda-breadcrumbs-separator)))
																	(if (eq "" s) "" (concat s org-agenda-breadcrumbs-separator))))))
					(setq time (cond (s2 (concat
																(org-agenda-time-of-day-to-ampm-maybe s1)
																"-" (org-agenda-time-of-day-to-ampm-maybe s2)
																(when org-agenda-timegrid-use-ampm " ")))
													 (s1 (concat
																(org-agenda-time-of-day-to-ampm-maybe s1)
																(if org-agenda-timegrid-use-ampm
																		(concat time-grid-trailing-characters " ")
																	time-grid-trailing-characters)))
													 (t ""))
								extra (or (and (not habitp) extra) "")
								category (if (symbolp category) (symbol-name category) category)
								level (or level ""))
					(if (string-match org-link-bracket-re category)
							(progn
								(setq l (string-width (or (match-string 2) (match-string 1))))
								(when (< l (or org-prefix-category-length 0))
									(setq category (copy-sequence category))
									(org-add-props category nil
										'extra-space (make-string
																	(- org-prefix-category-length l 1) ?\ ))))
						(when (and org-prefix-category-max-length
											 (>= (length category) org-prefix-category-max-length))
							(setq category (substring category 0 (1- org-prefix-category-max-length)))))
					;; Evaluate the compiled format
					(setq rtn (concat (eval formatter) txt))

					;; And finally add the text properties
					(remove-text-properties 0 (length rtn) '(line-prefix t wrap-prefix t) rtn)
					(org-add-props rtn nil
						'org-category category
						'tags (mapcar 'org-downcase-keep-props tags)
						'org-highest-priority org-highest-priority
						'org-lowest-priority org-lowest-priority
						'time-of-day time-of-day
						'duration duration
						'breadcrumbs breadcrumbs
						'txt txt
						'level level
						'time time
						'extra extra
						'format org-prefix-format-compiled
						'dotime dotime)))))
#+end_src
