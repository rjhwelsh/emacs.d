#+TITLE: Sunrise/Sunset functions
#+AUTHOR: Roger J. H. Welsh
#+EMAIL: rjhwelsh@posteo.net
#+PROPERTY: header-args    :results silent

These functions have been taken from.
https://stackoverflow.com/questions/22889036/custom-diary-sunrise-function-not-working-autoload-diary-emacs
Credit to Brady Trainor.

These functions build on solar.el
#+begin_src emacs-lisp
(require 'solar)
#+end_src

* Sunrise
	#+begin_src emacs-lisp
	(defun solar-sunrise-string (date &optional nolocation)
  "String of *local* time of sunrise and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s (%s hours daylight)"
     (if (car l)
     (concat (apply 'solar-time-string (car l)) " Sunrise")
       "no sunrise")
     (nth 2 l)
     )))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunrise ()
  "Local time of sunrise as a diary entry.
  Accurate to a few seconds."
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunrise-string date))
	#+end_src

* Sunset
	#+begin_src emacs-lisp
	(defun solar-sunset-string (date &optional nolocation)
  "String of *local* time of sunset and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
     "%s (%s hours daylight)"
     (if (cadr l)
     (concat (apply 'solar-time-string (cadr l)) " Sunset" )
       "no sunset")
     (nth 2 l)
     )))
;; To be called from diary-list-sexp-entries, where DATE is bound.
;;;###diary-autoload
(defun diary-sunset ()
  "Local time of sunset as a diary entry.
  Accurate to a few seconds."
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
      (solar-setup))
  (solar-sunset-string date))
	#+end_src

* Patch :org:org:agenda:
Add a patch to allow times to be defined with sexp-expressions.
Time is defined in the string portion returned by the sexp.
The time must be at the start of the string.

** org.el
Define function to obtain time from sexp expressions.
#+begin_src emacs-lisp
	(defun org-timestamp-from-sexp (s d)
		"Convert Org timestamp S, as a sexp-string, into a timestamp object for date D.
				Return nil if S is not a valid timestamp sexp"
    (require 'diary-lib)
		(let (
					(ts
					 (format "%04d"
									 (diary-entry-time
										(diary-sexp-entry s "" d)))
					 ))
			(string-match "\\(..\\)\\(..\\)" ts)
			(concat
			 (match-string 1 ts)
			 ":"
			 (match-string 2 ts))
			)
		)
	(org-timestamp-from-sexp "(diary-sunrise)" (calendar-current-date))
#+end_src

** org-agenda.el
#+begin_src emacs-lisp
	(defun org-agenda-get-sexps ()
		"Return the sexp information for agenda display. (PATCHED)"
		(require 'diary-lib)
		(let* ((props (list 'face 'org-agenda-calendar-sexp
												'mouse-face 'highlight
												'help-echo
												(format "mouse-2 or RET jump to org file %s"
																(abbreviate-file-name buffer-file-name))))
					 (regexp "^&?%%(")
					 marker category extra level ee txt tags entry
					 result beg b sexp sexp-entry todo-state warntime inherited-tags)
			(goto-char (point-min))
			(while (re-search-forward regexp nil t)
				(catch :skip
					(org-agenda-skip)
					(setq beg (match-beginning 0))
					(goto-char (1- (match-end 0)))
					(setq b (point))
					(forward-sexp 1)
					(setq sexp (buffer-substring b (point)))
					(setq sexp-entry (if (looking-at "[ \t]*\\(\\S-.*\\)")
															 (org-trim (match-string 1))
														 ""))
					(setq result (org-diary-sexp-entry sexp sexp-entry date))
				;; Obtain time from sexp
					(setq ts (org-timestamp-from-sexp sexp date))

					(when result
						(setq marker (org-agenda-new-marker beg)
									level (make-string (org-reduced-level (org-outline-level)) ? )
									category (org-get-category beg)
									inherited-tags
									(or (eq org-agenda-show-inherited-tags 'always)
											(and (listp org-agenda-show-inherited-tags)
													 (memq 'agenda org-agenda-show-inherited-tags))
											(and (eq org-agenda-show-inherited-tags t)
													 (or (eq org-agenda-use-tag-inheritance t)
															 (memq 'agenda org-agenda-use-tag-inheritance))))
									tags (org-get-tags nil (not inherited-tags))
									todo-state (org-get-todo-state)
									warntime (get-text-property (point) 'org-appt-warntime)
									extra nil)

						(dolist (r (if (stringp result)
													 (list result)
												 result)) ;; we expect a list here

							(when (and org-agenda-diary-sexp-prefix
												 (string-match org-agenda-diary-sexp-prefix r))
								(setq extra (match-string 0 r)
											r (replace-match "" nil nil r)))

							(if (string-match "\\S-" r)
									(setq txt r)
								(setq txt "SEXP entry returned empty string"))

						  ;; Add time-string if available
							(when ts
								(setq txt (concat txt " " ts)))

							(setq txt (org-agenda-format-item extra txt level category tags 'time))

							(org-add-props txt props 'org-marker marker
														 'date date 'todo-state todo-state
														 'level level 'type "sexp" 'warntime warntime)

							(push txt ee))
						)))
			(nreverse ee)))
#+end_src
