#+TITLE: Getting Things Done with Org-mode
#+AUTHOR: Roger J. H. Welsh
#+EMAIL: rjhwelsh@posteo.net
#+PROPERTY: header-args :results silent
#+STARTUP: content

* Agenda
  :PROPERTIES:
  :PPID:
  :END:
  :LOGBOOK:
  - Refiled on [2020-10-14 Wed 22:47]
  :END:
** Keywords
   Workflow states have been taken from gjstein/sachachua.
   See gjstein [[http://cachestocaches.com/2016/9/my-workflow-org-agenda/#][here]].
   See sachachua [[https://sachachua.com/blog/2007/12/emacs-getting-things-done-with-org-basic/][here]].

   - todo :: Indicate tasks / projects which need to get done
   - next :: Tasks which are being done "next" within a particular project
   - started :: Tasks which have been started
   - waiting :: Tasks waiting on someone else.
     Log notes on what this is waiting on.
   - done :: Completed task

   For below; make the following notes:
   + Expressions may be a "sequence" or "type" ; "type" goes straight to DONE
     after completion. Sequences rotate through all keywords.
   + TODO = the todo keyword
   + (t) = the fast key shortcut
   + ! means LOG timestamp when changing *TO* state.
   + @ means LOG note when changing *TO* state.
   + X/Y means perform X when changing *TO* state, and Y when changing *FROM* state.
   #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
	   '((sequence "TODO(t)" "NEXT(n)" "STARTED(s!)" "WAITING(w!/!)" "|" "DONE(d!)")
	     ))
   #+END_SRC
   + org-log-into-drawer LOGS everything into a hidden drawer, so everything looks cleaner.
   #+BEGIN_SRC emacs-lisp
     (setq org-log-into-drawer t) ;;LOGBOOK
   #+END_SRC

   For group projects, put this at the top of the project line for custom keywords.
   #+BEGIN_EXAMPLE
   #+TYP_TODO: @MYNAME(m) @NAME1(1) @NAME2(2) | DONE(d)
   #+END_EXAMPLE

** Tags
   Tags represent environmental conditions before a task can be undertaken.
   Tasks should be organized by a hierarchy of projects and sub-projects.
   Projects are prioritized, tags develop views for batch processing tasks.

   IF <tag> THEN <task>
   IF <condition> THEN <task>
   IF <tag1> AND <tag2> AND ... THEN <task>

   Tags should not be inherited by sub-tasks.
   Sub-tasks should differentiate work dependencies only.

*** Default tags
    See =org-tag-alist= for more details.
    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '())
    #+END_SRC
*** Tag inheritance
    Inherit all tags.
    #+BEGIN_SRC emacs-lisp
      (setq org-use-tag-inheritance t)
    #+END_SRC

    This will exclude all tags from =org-tag-persistent-alist= from being inherited.
    #+BEGIN_SRC emacs-lisp
      (setq org-tags-exclude-from-inheritance (mapcar 'car org-tag-persistent-alist))
    #+END_SRC

*** Functions to expire tags
    Expiration tags are temporary tags for grouping TODO items in a short-term
    meaningful way. These functions quickly expunge these temporary tags in bulk, to
    facilitate better short-term planning and turnover.

    Expiration tags.
    #+BEGIN_SRC emacs-lisp
      (defcustom rjh/org-tags-expiration-tags
	(mapcar 'car org-tag-persistent-alist)
	"Org-mode tags which can be removed quickly, with org-tags-expire."
	;; The rest of this is copied from org-tag-persistent-alist
	:group 'org-tags
	:type '(repeat
		(choice
		 (cons :tag "Tag with key"
		       (string    :tag "Tag name")
		       (character :tag "Access char"))
		 (list :tag "Tag" (string :tag "Tag name"))
		 (const :tag "Start radio group" (:startgroup))
		 (const :tag "Start tag group, non distinct" (:startgrouptag))
		 (const :tag "Group tags delimiter" (:grouptags))
		 (const :tag "End radio group" (:endgroup))
		 (const :tag "End tag group, non distinct" (:endgrouptag))
		 (const :tag "New line" (:newline)))))
    #+END_SRC

    Generic interactive function.
    - Will expire tags for current item
    - Will expire tags for entire buffer when called with a prefix.
    #+BEGIN_SRC emacs-lisp
      (defun rjh/org-tags-expire (ARG)
	"Expires all expiration tags.
      PREFIXARG = Expire tags in buffer if non-nil"
	(interactive "p")
	(if (>= ARG 4)
	    (rjh/org-tags-expire-buffer)
	  (if (org-region-active-p)
	      (call-interactively 'rjh/org-tags-expire-region)
	    (rjh/org-tags-expire-entry))))
    #+END_SRC

**** org-mode
     These provide functions for removing expiration-tags in the current
     =org-mode= buffer.

     Tag expiration for headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-headline ( expiration-tags )
	 "Removes all expiration tags from headline."
	 (let ((newtagslist (org-get-tags nil t)))
	   (unless (null newtagslist)
	     (dolist (element expiration-tags)
	       (when (member element newtagslist)
		 (setq newtagslist (delete element newtagslist))))
	     (org-set-tags newtagslist)
	     (org-reveal))))
     #+END_SRC

     Tag expiration for entry (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-entry ()
	 "Expires all expiration tags in current entry."
	 (interactive)
	 (save-excursion
	   (org-back-to-heading 't)
	   (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags)))
     #+END_SRC

     Tags expiration for buffer (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-buffer ()
	 "Expires all expiration tags in current buffer.
       Includes invisible heading lines."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (outline-next-heading)
	     (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Tags expiration for a region of an org buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-region (start end)
	 "Expires all expiration tags in current region."
	 (interactive "r")
	 (dolist (element rjh/org-tags-expiration-tags)
	   (org-change-tag-in-region start end element 'off)))
     #+END_SRC

**** org-agenda
     These are functions to remove expiration tags in the =org-agenda=.

     Tag expiration for an agenda headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-headline ( expiration-tags )
	 "Removes all expiration tags from an AGENDA headline."
	 (dolist (element expiration-tags)
	   (org-agenda-set-tags element 'off)))
     #+END_SRC

     Tag expiration for an agenda buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-buffer ()
	 "Removes all expiration tags from an AGENDA buffer."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (and (org-agenda-next-item 1)
		       (next-single-property-change (point-at-eol) 'org-marker))
	     (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Generic interactive agenda function.
     - Will expire selected headlines
     - Will expire whole agenda buffer with prefix.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda (ARG)
	 "Expires tags in org-agenda view."
	 (interactive "p")
	 (save-excursion
	   (if (>= ARG 4)
	       (rjh/org-tags-expire-agenda-buffer)
	     (if (org-region-active-p)
		 (call-interactively 'rjh/org-tags-expire-region)
	       (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags)))))
     #+END_SRC

*** Column
    Set tag column formatting relative to headline.
    #+begin_src emacs-lisp
      (setq org-tags-column 0)
    #+end_src

    Set tag column formatting for agenda.
    #+begin_src emacs-lisp
      (setq org-agenda-tags-column -80)
    #+end_src

** Views
*** Agenda Files
    Store the list of agenda files in ...
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files "~/.emacs.d/agenda-files" )
    #+END_SRC
*** Include diary entries
    #+begin_src emacs-lisp
      (setq org-agenda-include-diary t)
    #+end_src
*** Sorting Strategy
    Sorting strategy.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-sorting-strategy
	    '((agenda time-up deadline-up scheduled-up todo-state-down category-keep              priority-down effort-up tag-up)
	      (todo           priority-down effort-up  todo-state-down deadline-up category-keep tag-up)
	      (tags                                    todo-state-down category-keep  deadline-up priority-down effort-up tag-up)
	      (search         deadline-up              todo-state-down category-keep              priority-down effort-up tag-up)))
    #+END_SRC
*** Agenda Default Prefix
    Prefix format
    #+begin_src emacs-lisp
      (setq org-agenda-prefix-format
	    '((agenda . "%?-12t%?-12s ")
	      (todo .   "%12:c ")
	      (tags .   "%12:c ")
	      (search . "%12:c%b "))
	    )
    #+end_src
*** Agenda Skip Functions
**** Global
     #+begin_src emacs-lisp
       (setq org-agenda-skip-function-global '(org-agenda-skip-entry-if 'todo 'done))
     #+end_src
     Standard function for skipping entries
     - =(org-agenda-skip-entry-if &rest CONDITIONS)= :: Skip if any of the CONDITIONS
       are true
       - ='scheduled= :: Entry has a scheduled time.
       - ='deadline= :: Entry has a deadline.
       - ='timestamp= :: Entry has any timestamp (including deadline or scheduled)
       - ='todo= :: Entry todo keyword matches (accepts as argument a list of todo keywords)
	 - ='("TODO" "DONE")= :: Matches any of TODO or DONE.
	 - ='done= :: Matches keyword class 'done
	 - ='todo= :: Matches keyword class 'todo
**** Org-agenda-skip-function
     Use =org-agenda-skip-function= option to define a function to skip entries. 
     - When the function returns nil, the entry will be skipped
     - Otherwise the function must return a position from where the search should continue
#+begin_example el
(let (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
#+end_example

**** Skip non archive-able tasks
     A function for skipping non-archive-able tasks in the agenda-view from Bernt Hansen.
     #+BEGIN_SRC emacs-lisp
       (defun bh/skip-non-archivable-tasks ()
	 "Skip trees that are not available for archiving"
	 (save-restriction
	   (widen)
	   ;; Consider only tasks with done todo headings as archivable candidates
	   (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		 (subtree-end (save-excursion (org-end-of-subtree t))))
	     (if (member (org-get-todo-state) org-todo-keywords-1)
		 (if (member (org-get-todo-state) org-done-keywords)
		     (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
			    (a-month-ago (* 60 60 24 (+ daynr 1)))
			    (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
			    (this-month (format-time-string "%Y-%m-" (current-time)))
			    (subtree-is-current (save-excursion
						  (forward-line 1)
						  (and ( < (point) subtree-end) ; This line is causing a bracket mismatch
						       (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
		       (if subtree-is-current
			   subtree-end ; Has a date in this month or last month, skip it
			 nil))  ; available to archive
		   (or subtree-end (point-max)))
	       next-headline))))
     #+END_SRC

*** Custom Agenda View Defaults
    Set default agenda span for a single day.
    #+begin_src emacs-lisp
      (setq org-agenda-span 1)
    #+end_src

*** Custom Agenda View
    NB =`= backquote allows evaluation of selected element in the quoted list.
    =,= is used to indicate items to be evaluated.

    Sparse trees cannot be used in assembled views; they operate on the current
    buffer only.
 
    ps-print is required for exporting views
    #+begin_src emacs-lisp
      (require 'ps-print)
    #+end_src
    
    Set current custom agenda views to an empty list.
    #+begin_src emacs-lisp
    (setq org-agenda-custom-commands '())
    #+end_src

Standard export location for org-agenda-views
#+begin_src emacs-lisp
  (defun org-agenda-filename-to-export-views (filename exts)
    "Returns a standard location to export agenda views to"
    (progn 
      (mapcar
       (lambda (x)
	 (expand-file-name
	  (concat filename "." x)
	  org-directory
	  ))
       exts)
      )
    )
#+end_src

Re-use a view defined in org-agenda-custom-commands
#+begin_example emacs-lisp
;; Returns the view, incl settings defined by prefix key
 (nth 3 (assoc "A" org-agenda-custom-commands))
#+end_example


    *Persistent tags*
    Select todo items with a specific persistent tag. *P*

    #+begin_src emacs-lisp
      ;; Generator for persistent-tag-agenda-views
      (defun org-agenda-tag-persistent-agenda-views (&optional settings filename exts)
	"Generates a list of custom-commands for org-agenda to display persistent-tags"
	(progn
	  (mapcar
	   (lambda (tag)
	     `(,(car tag) . (tags
			     ,(concat "+" (car tag))
			     ,settings
			     ,(org-agenda-filename-to-export-views (concat filename (car tag)) exts)
			     )))
	   org-tag-persistent-alist)

	  )
	)

      ;; Add a custom view for each persistent tag under a prefix
      (let* (
	     (persistent-tag-prefix-key "P")
	     (tag-persistent-agenda-commands
	      (lambda (&optional settings filename exts)
		(mapcar
		 (lambda (tag_arr)
		   (let ((tag (car tag_arr)))
		     (append
		      `(
			,(concat persistent-tag-prefix-key (substring tag 0 1)) ; PREFIX
			,(format "Headlines with TAGS match: %s" tag)) ; DESCRIPTION
		      (cdr (assoc tag (org-agenda-tag-persistent-agenda-views settings filename exts)))
		      )
		     ))
		 org-tag-persistent-alist
		 )))
	     )
	(setq org-agenda-custom-commands
	      (append 
	       org-agenda-custom-commands
	       `((,persistent-tag-prefix-key . "Todo items with specific persistent tag")) ; Prefix command
	       (funcall tag-persistent-agenda-commands
			'((org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
			  (ps-print-color-p nil)
			  (ps-number-of-columns 1)
			  (ps-left-header (list 'org-agenda-write-buffer-name))
			  (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			"agenda/tag/"
			'("ps" "html"))
	       )))
    #+end_src


    Select todo items with any persistent tag. *p*
    #+begin_src emacs-lisp
      ;; Search for any persistent-tags
      (setq org-agenda-select-persistent-tags
	    (apply 'concat
		   (cdr
		    (apply 'append
			   (mapcar
			    (lambda (tag)
			      (list "|" (car tag))
			      )
			    org-tag-persistent-alist))
		    )))
      ;; Tags tree
      (add-to-list 'org-agenda-custom-commands
		   `("p" "Todo items with persistent tags"
		     tags-tree ,org-agenda-select-persistent-tags)
		   )
    #+end_src

    Select todo items without any persistent tags. *u*
    Other tags (Export)
    #+begin_src emacs-lisp
      ;; Search for anything without a persistent tag
      (setq org-agenda-deselect-persistent-tags
	    (apply
	     'concat
	     (mapcar
	      (lambda (tag)
		(concat "-" (car tag))
		)
	      org-tag-persistent-alist)
	     )
	    )
      ;; Tags-tree 
      (add-to-list 'org-agenda-custom-commands 
		   `("u" "Todo items without persistent tags"
		     tags-tree ,org-agenda-deselect-persistent-tags)
		   )

      ;; Export view for untagged tasks
      (add-to-list 'org-agenda-custom-commands
		   `("O" "Other tags (EXPORT)" .
		     (tags-todo
		      ,org-agenda-deselect-persistent-tags
		      ,(append
			'((org-agenda-overriding-header "Remaining TODO items:")
			  (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'todo 'done)))
			'((ps-number-of-columns 1)
			  (ps-print-color-p nil)
			  (ps-left-header (list 'org-agenda-write-buffer-name))
			  (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			)
		      ,(org-agenda-filename-to-export-views "agenda/tag/OTHER" '("ps" "html"))
		      )))
    #+end_src


"Agenda view"
    #+begin_src emacs-lisp
      (add-to-list 'org-agenda-custom-commands
		   `("A" "Agenda View" .
		     `(agenda
		       '(
			 (org-agenda-skip-function nil)
			 (org-agenda-span 1)
			 (ps-print-color-p nil)
			 (ps-left-header (list 'org-agenda-write-buffer-name))
			 (ps-number-of-columns 1)
			 (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
			 )
		       ,(org-agenda-filename-to-export-views "agenda/agenda" '("ps" "html"))
		       ))
		   )
    #+end_src

"Year Agenda View (ICS)"
    #+begin_src emacs-lisp
      (add-to-list 'org-agenda-custom-commands
		   `("Y" "Year Agenda View (ICS)" agenda ""
		     ((org-agenda-span 366)
		      (org-agenda-remove-tags t)
		      (ps-number-of-columns 1)
		      (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
		      (org-agenda-skip-function nil)
		      )
		     ,(org-agenda-filename-to-export-views
		       "agenda/agenda"
		       '("ics"))
		     ))
    #+end_src

Stuck projects (EXPORT)
#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
		 `("S" "Stuck projects (EXPORT)" .
		   (stuck ""
			     '((ps-number-of-columns 1)
			       (ps-left-header (list 'org-agenda-write-buffer-name))
			       (ps-print-color-p nil)
			       (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			     ,(org-agenda-filename-to-export-views 
			       "agenda/stuck"
			       '("ps" "html"))
  )))
#+end_src


Tasks to Archive
#+begin_src emacs-lisp
  (add-to-list 'org-agenda-custom-commands
	       '("X" "Tasks to Archive" todo ""
		 ;; tags ,deselect-persistent-tags
		 ((org-agenda-overriding-header "Tasks to Archive")
		  (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		  (org-tags-match-list-sublevels nil))
		 ))
#+end_src

"Active view"
"Summary view"
"Organiser view"
    #+begin_src emacs-lisp
      ;; Define full-view compilation
      (defun org-agenda-full-view nil
       "Compilation overview generator for org-agenda-custom-commands."
	(append
	 `(
	   ,(nth 3 (assoc "A" org-agenda-custom-commands)))
	   (mapcar 'cdr
		   (org-agenda-tag-persistent-agenda-views
		    (append
		     '(
		       (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
		       )
		     )))
	   `(,(nth 3 (assoc "O" org-agenda-custom-commands))
	     ,(nth 3 (assoc "S" org-agenda-custom-commands)))
	     ))
    #+end_src
    #+begin_src emacs-lisp
      ;; Active view
      (add-to-list 'org-agenda-custom-commands
		   `("n" "Active View"
		     ,(org-agenda-full-view)
		     ((ps-number-of-columns 1)
		      (ps-left-header (list 'org-agenda-write-buffer-name))
		      (ps-print-color-p nil)
		      (ps-landscape-mode t))
		     ,(org-agenda-filename-to-export-views "agenda/full" '("ps" "html"))
		     ))
    #+end_src
    #+begin_src emacs-lisp
      ;; Summary view
      (add-to-list 'org-agenda-custom-commands
		   `("s" "Summary View"
		     ,(org-agenda-full-view)
		     ,(let (
			    (summary-side-margin (* (/ 1 2.54) 72))
			    (summary-border-file "~/.emacs.d/ps/summary_border.ps")
			    )
		     `((org-agenda-start-day "+1d")
		      (org-agenda-span 3)
		      (org-agenda-remove-tags t)
		      (org-agenda-block-separator nil)
		      (ps-print-color-p nil)
		      (ps-left-header (list 'org-agenda-write-buffer-name))
		      (ps-paper-type 'collinsorg3colA4)
		      (ps-number-of-columns 3)
		      (ps-print-background-image `((,summary-border-file ,(- 0 summary-side-margin) ,(- 0 ps-bottom-margin))))
		      (ps-landscape-mode t)
		      (ps-left-margin ,summary-side-margin)
		      (ps-right-margin ,summary-side-margin)
		      (ps-inter-column (* ,summary-side-margin 2))
		      (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")))
		     ,(org-agenda-filename-to-export-views "agenda/summary" '("ps" "html"))
		     ))
    #+end_src
    #+begin_src emacs-lisp
      ;; Organiser view
      (add-to-list 'org-agenda-custom-commands
		   `("o" "Organiser View"
		     ,(org-agenda-full-view)
		     ((org-agenda-start-day "+1d")
		      (org-agenda-span 3)
		      (org-agenda-remove-tags t)
		      (org-agenda-block-separator nil)
		      (ps-print-color-p nil)
		      (ps-left-header (list 'org-agenda-write-buffer-name))
		      (ps-number-of-columns 1)
		      (ps-paper-type 'collinsorganiser)
		      (ps-left-margin (* (/ 1 2.54) 72))
		      (ps-right-margin (* (/ 1 2.54) 72))
		      (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
		     ,(org-agenda-filename-to-export-views "agenda/collins" '("ps"))
		     ))
    #+end_src

*** Agenda Window
    Take up current window when called.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-window-setup 'current-window)
    #+END_SRC

** Stuck Projects
   1. Match projects as
      1. Any LEVEL 1 headline
      2. Do not match completed headlines
      3. Do not match items tagged with NOARCHIVE
      3. Do not match items tagged with DOC; documentation-only
   2. Non-stuck projects have headlines which contain a NEXT todo-keyword.
   3. Non-stuck projects have headlines which may contain a specific tag; but not
      in this case.
   4. Non-stuck projects are identified if the special word IGNORE is matched
      anywhere.
   #+BEGIN_SRC emacs-lisp
     (setq org-stuck-projects
	   '("-DOC-NOARCHIVE+LEVEL=1/-DONE" ("NEXT") nil "\\<IGNORE\\>"))
   #+END_SRC

** Priorities
*** Keys
    Use "C-c ," to quickly set priorities.
    Only "," is required in agenda.

*** Default Priority Values
    Priorities are assigned A,B,C,D (E,F). B being the default.
    I'm particularly inspired by the Eisenhower Matrix and Must/Should/Nice todos.
    For reference, see the table below. Typically, one should attempt to accomplish
    as many B's in a day as possible; while also taking regular breaks.
    If you have nothing left todo, D's are pleasant enough.

    | PRIORITY   | NOT IMPORTANT | IMPORTANT  |
    |------------+---------------+------------|
    | NOT URGENT | D - PLEASANT  | B - SHOULD |
    |------------+---------------+------------|
    | URGENT     | C - NICE      | A - MUST   |
    |------------+---------------+------------|

    So.. one way to describe my priorities, would be...
    #+BEGIN_EXAMPLE
    #+PRIORITIES: C A F .
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (setq org-default-priority ?D)
      (setq org-highest-priority ?A)
      (setq org-lowest-priority ?F)
    #+END_SRC

** Dependencies
   Dependency settings.
   This allows for task blocking/etc.
   #+BEGIN_SRC emacs-lisp
     (setq org-enforce-todo-dependencies t)
     (setq org-agenda-dim-blocked-tasks t)
     (setq org-enforce-todo-checkbox-dependencies nil)
   #+END_SRC

