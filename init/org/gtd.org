#+TITLE: Getting Things Done with Org-mode
#+AUTHOR: Roger J. H. Welsh
#+EMAIL: rjhwelsh@posteo.net
#+PROPERTY: header-args :results silent
#+STARTUP: content

* Agenda
  :PROPERTIES:
  :PPID:
  :END:
  :LOGBOOK:
  - Refiled on [2020-10-14 Wed 22:47]
  :END:
** Keywords
   Workflow states have been taken from gjstein/sachachua.
   See gjstein [[http://cachestocaches.com/2016/9/my-workflow-org-agenda/#][here]].
   See sachachua [[https://sachachua.com/blog/2007/12/emacs-getting-things-done-with-org-basic/][here]].

   - todo :: Indicate tasks / projects which need to get done
   - next :: Tasks which are being done "next" within a particular project
   - started :: Tasks which have been started
   - waiting :: Tasks waiting on someone else.
     Log notes on what this is waiting on.
   - done :: Completed task

   For below; make the following notes:
   + Expressions may be a "sequence" or "type" ; "type" goes straight to DONE
     after completion. Sequences rotate through all keywords.
   + TODO = the todo keyword
   + (t) = the fast key shortcut
   + ! means LOG timestamp when changing *TO* state.
   + @ means LOG note when changing *TO* state.
   + X/Y means perform X when changing *TO* state, and Y when changing *FROM* state.
   #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
	   '((sequence "TODO(t)" "NEXT(n)" "STARTED(s!)" "WAITING(w!/!)" "|" "DONE(d!)")
	     ))
   #+END_SRC
   + org-log-into-drawer LOGS everything into a hidden drawer, so everything looks cleaner.
   #+BEGIN_SRC emacs-lisp
     (setq org-log-into-drawer t) ;;LOGBOOK
   #+END_SRC

   For group projects, put this at the top of the project line for custom keywords.
   #+BEGIN_EXAMPLE
   #+TYP_TODO: @MYNAME(m) @NAME1(1) @NAME2(2) | DONE(d)
   #+END_EXAMPLE

** Tags
   Tags represent environmental conditions before a task can be undertaken.
   Tasks should be organized by a hierarchy of projects and sub-projects.
   Projects are prioritized, tags develop views for batch processing tasks.

   IF <tag> THEN <task>
   IF <condition> THEN <task>
   IF <tag1> AND <tag2> AND ... THEN <task>

   Tags should not be inherited by sub-tasks.
   Sub-tasks should differentiate work dependencies only.

*** Default tags
    See =org-tag-alist= for more details.
    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '())
    #+END_SRC
*** Tag inheritance
    Inherit all tags.
    #+BEGIN_SRC emacs-lisp
      (setq org-use-tag-inheritance t)
    #+END_SRC

    This will exclude all tags from =org-tag-persistent-alist= from being inherited.
    #+BEGIN_SRC emacs-lisp
      (setq org-tags-exclude-from-inheritance (mapcar 'car org-tag-persistent-alist))
    #+END_SRC

*** Functions to expire tags
    Expiration tags are temporary tags for grouping TODO items in a short-term
    meaningful way. These functions quickly expunge these temporary tags in bulk, to
    facilitate better short-term planning and turnover.

    Expiration tags.
    #+BEGIN_SRC emacs-lisp
      (defcustom rjh/org-tags-expiration-tags
	(mapcar 'car org-tag-persistent-alist)
	"Org-mode tags which can be removed quickly, with org-tags-expire."
	;; The rest of this is copied from org-tag-persistent-alist
	:group 'org-tags
	:type '(repeat
		(choice
		 (cons :tag "Tag with key"
		       (string    :tag "Tag name")
		       (character :tag "Access char"))
		 (list :tag "Tag" (string :tag "Tag name"))
		 (const :tag "Start radio group" (:startgroup))
		 (const :tag "Start tag group, non distinct" (:startgrouptag))
		 (const :tag "Group tags delimiter" (:grouptags))
		 (const :tag "End radio group" (:endgroup))
		 (const :tag "End tag group, non distinct" (:endgrouptag))
		 (const :tag "New line" (:newline)))))
    #+END_SRC

    Generic interactive function.
    - Will expire tags for current item
    - Will expire tags for entire buffer when called with a prefix.
    #+BEGIN_SRC emacs-lisp
      (defun rjh/org-tags-expire (ARG)
	"Expires all expiration tags.
      PREFIXARG = Expire tags in buffer if non-nil"
	(interactive "p")
	(if (>= ARG 4)
	    (rjh/org-tags-expire-buffer)
	  (if (org-region-active-p)
	      (call-interactively 'rjh/org-tags-expire-region)
	    (rjh/org-tags-expire-entry))))
    #+END_SRC

**** org-mode
     These provide functions for removing expiration-tags in the current
     =org-mode= buffer.

     Tag expiration for headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-headline ( expiration-tags )
	 "Removes all expiration tags from headline."
	 (let ((newtagslist (org-get-tags nil t)))
	   (unless (null newtagslist)
	     (dolist (element expiration-tags)
	       (when (member element newtagslist)
		 (setq newtagslist (delete element newtagslist))))
	     (org-set-tags newtagslist)
	     (org-reveal))))
     #+END_SRC

     Tag expiration for entry (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-entry ()
	 "Expires all expiration tags in current entry."
	 (interactive)
	 (save-excursion
	   (org-back-to-heading 't)
	   (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags)))
     #+END_SRC

     Tags expiration for buffer (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-buffer ()
	 "Expires all expiration tags in current buffer.
       Includes invisible heading lines."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (outline-next-heading)
	     (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Tags expiration for a region of an org buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-region (start end)
	 "Expires all expiration tags in current region."
	 (interactive "r")
	 (dolist (element rjh/org-tags-expiration-tags)
	   (org-change-tag-in-region start end element 'off)))
     #+END_SRC

**** org-agenda
     These are functions to remove expiration tags in the =org-agenda=.

     Tag expiration for an agenda headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-headline ( expiration-tags )
	 "Removes all expiration tags from an AGENDA headline."
	 (dolist (element expiration-tags)
	   (org-agenda-set-tags element 'off)))
     #+END_SRC

     Tag expiration for an agenda buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-buffer ()
	 "Removes all expiration tags from an AGENDA buffer."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (and (org-agenda-next-item 1)
		       (next-single-property-change (point-at-eol) 'org-marker))
	     (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Generic interactive agenda function.
     - Will expire selected headlines
     - Will expire whole agenda buffer with prefix.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda (ARG)
	 "Expires tags in org-agenda view."
	 (interactive "p")
	 (save-excursion
	   (if (>= ARG 4)
	       (rjh/org-tags-expire-agenda-buffer)
	     (if (org-region-active-p)
		 (call-interactively 'rjh/org-tags-expire-region)
	       (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags)))))
     #+END_SRC

*** Column
    Set tag column formatting relative to headline.
    #+begin_src emacs-lisp
      (setq org-tags-column 0)
    #+end_src

    Set tag column formatting for agenda.
    #+begin_src emacs-lisp
      (setq org-agenda-tags-column -80)
    #+end_src

** Views
*** Agenda Files
    Store the list of agenda files in ...
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files "~/.emacs.d/agenda-files" )
    #+END_SRC
*** Include diary entries
    #+begin_src emacs-lisp
      (setq org-agenda-include-diary t)
    #+end_src
*** Sorting Strategy
    Sorting strategy.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-sorting-strategy
	    '((agenda time-up deadline-up scheduled-up todo-state-down category-keep              priority-down effort-up tag-up)
	      (todo           priority-down effort-up  todo-state-down deadline-up category-keep tag-up)
	      (tags                                    todo-state-down category-keep  deadline-up priority-down effort-up tag-up)
	      (search         deadline-up              todo-state-down category-keep              priority-down effort-up tag-up)))
    #+END_SRC
*** Agenda Default Prefix
    Prefix format
    #+begin_src emacs-lisp
      (setq org-agenda-prefix-format
	    '((agenda . "%?-12t%?-12s ")
	      (todo .   "%12:c ")
	      (tags .   "%12:c ")
	      (search . "%12:c%b "))
	    )
    #+end_src
*** Agenda Skip Functions
**** Global
     #+begin_src emacs-lisp
       (setq org-agenda-skip-function-global '(org-agenda-skip-entry-if 'todo 'done))
     #+end_src
     Standard function for skipping entries
     - =(org-agenda-skip-entry-if &rest CONDITIONS)= :: Skip if any of the CONDITIONS
       are true
       - ='scheduled= :: Entry has a scheduled time.
       - ='deadline= :: Entry has a deadline.
       - ='timestamp= :: Entry has any timestamp (including deadline or scheduled)
       - ='todo= :: Entry todo keyword matches (accepts as argument a list of todo keywords)
	 - ='("TODO" "DONE")= :: Matches any of TODO or DONE.
	 - ='done= :: Matches keyword class 'done
	 - ='todo= :: Matches keyword class 'todo
**** Org-agenda-skip-function
     Use =org-agenda-skip-function= option to define a function to skip entries. 
     - When the function returns nil, the entry will be skipped
     - Otherwise the function must return a position from where the search should continue
#+begin_example el
(let (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
#+end_example

**** Skip non archive-able tasks
     A function for skipping non-archive-able tasks in the agenda-view from Bernt Hansen.
     #+BEGIN_SRC emacs-lisp
       (defun bh/skip-non-archivable-tasks ()
	 "Skip trees that are not available for archiving"
	 (save-restriction
	   (widen)
	   ;; Consider only tasks with done todo headings as archivable candidates
	   (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		 (subtree-end (save-excursion (org-end-of-subtree t))))
	     (if (member (org-get-todo-state) org-todo-keywords-1)
		 (if (member (org-get-todo-state) org-done-keywords)
		     (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
			    (a-month-ago (* 60 60 24 (+ daynr 1)))
			    (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
			    (this-month (format-time-string "%Y-%m-" (current-time)))
			    (subtree-is-current (save-excursion
						  (forward-line 1)
						  (and ( < (point) subtree-end) ; This line is causing a bracket mismatch
						       (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
		       (if subtree-is-current
			   subtree-end ; Has a date in this month or last month, skip it
			 nil))  ; available to archive
		   (or subtree-end (point-max)))
	       next-headline))))
     #+END_SRC

*** Custom Agenda View Defaults
    Set default agenda span for a single day.
    #+begin_src emacs-lisp
      (setq org-agenda-span 1)
    #+end_src

*** Custom Agenda View
    NB =`= backquote allows evaluation of selected element in the quoted list.
    =,= is used to indicate items to be evaluated.

    Sparse trees cannot be used in assembled views; they operate on the current
    buffer only.

    #+BEGIN_SRC emacs-lisp
      (require 'ps-print)
      (let (
	    (deselect-persistent-tags
	     (apply
	      'concat
	      (mapcar
	       (lambda (tag)
		 (concat "-" (car tag))
		 )
	       org-tag-persistent-alist)
	      )
	     )

	    (select-persistent-tags
	     (apply 'concat
		    (cdr
		     (apply 'append
			    (mapcar
			     (lambda (tag)
			       (list "|" (car tag))
			       )
			     org-tag-persistent-alist))
		     ))
	     )

	    (filename-to-export-views
	     (lambda (filename exts)
	       (mapcar
		(lambda (x)
		  (expand-file-name
		   (concat filename "." x)
		   org-directory
		   ))
		exts)
	       )
	     )

	    (persistent-tag-prefix-key "P")
	    )

	(let* (
	       (tag-persistent-agenda-views
		(lambda (&optional settings filename exts)
		  (mapcar
		   (lambda (tag)
		     `(,(car tag) . (tags
				     ,(concat "+" (car tag))
				     ,settings
				     ,(funcall filename-to-export-views (concat filename (car tag)) exts)
				     )))
		   org-tag-persistent-alist))
		)

	       (agenda-view
		(lambda (&optional settings filename exts)
		  `(agenda ""
			   ,(append
			     '((org-agenda-skip-function nil)
			       )
			     settings)
			   ,(funcall filename-to-export-views filename exts))
		  ))

	       (other-tags-view
		(lambda (&optional settings filename exts)
		  `(tags-todo
		    ,deselect-persistent-tags
		    ,(append
		      '(
			(org-agenda-overriding-header "Remaining TODO items:")
			(org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'todo 'done))
			)
		      settings
		      )
		    ,(funcall filename-to-export-views filename exts)
		    )
		  ))

	       (stuck-view
		(lambda (&optional settings filename exts)
		  `(stuck ""
			  ,settings
			  ,(funcall filename-to-export-views filename exts)
			  )
		  ))

	       (full-view
		(lambda
		  (&optional
		   settings
		   filename
		   exts
		   )
		  (append
		   `(
		     ,(funcall agenda-view
			       settings
			       (concat filename "agenda") exts))
		   (mapcar 'cdr
			   (funcall tag-persistent-agenda-views
				    (append
				     '(
				       (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
				       )
				     settings
				     )
				    (concat filename "tag_")
				    exts))
		   `(
		     ,(funcall other-tags-view settings (concat filename "tag_OTHER") exts)
		     ,(funcall stuck-view settings (concat filename "stuck") exts)
		     ))
		  ))

	       (tag-persistent-agenda-commands
		(lambda (&optional settings filename exts)
		  (mapcar
		   (lambda (tag_arr)
		     (let ((tag (car tag_arr)))
		       (append
			`(
			  ,(concat persistent-tag-prefix-key (substring tag 0 1)) ; PREFIX
			  ,(format "Headlines with TAGS match: %s" tag)) ; DESCRIPTION
			(cdr (assoc tag (funcall tag-persistent-agenda-views settings filename exts)))
			)
		       ))
		   org-tag-persistent-alist
		   ))
		)
	       (summary-side-margin (* (/ 1 2.54) 72))
	       (summary-border-file "~/.emacs.d/ps/summary_border.ps")
	       )

	  (setq org-agenda-custom-commands
		(append
		 `(
		   ("n" "Active View"
		    ,(funcall full-view nil "agenda/" '("ps" "html"))
		    ((ps-number-of-columns 1)
		     (ps-left-header (list 'org-agenda-write-buffer-name))
		     (ps-print-color-p nil)
		     (ps-landscape-mode t))
		    ,(funcall filename-to-export-views "agenda/full" '("ps" "html"))
		    )
		   ("s" "Summary View"
		    ,(funcall full-view)
		    ((org-agenda-start-day "+1d")
		     (org-agenda-span 3)
		     (org-agenda-remove-tags t)
		     (org-agenda-block-separator nil)
		     (ps-print-color-p nil)
		     (ps-left-header (list 'org-agenda-write-buffer-name))
		     (ps-paper-type 'collinsorg3colA4)
		     (ps-number-of-columns 3)
		     (ps-print-background-image
		      '((,summary-border-file ,(- 0 summary-side-margin) ,(- 0 ps-bottom-margin))
			))
		     (ps-landscape-mode t)
		     (ps-left-margin ,summary-side-margin)
		     (ps-right-margin ,summary-side-margin)
		     (ps-inter-column (* ,summary-side-margin 2))
		     (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
		    ,(funcall filename-to-export-views "agenda/summary" '("ps" "html"))
		    )
		   ("o" "Organiser View"
		    ,(funcall full-view)
		    ((org-agenda-start-day "+1d")
		     (org-agenda-span 3)
		     (org-agenda-remove-tags t)
		     (org-agenda-block-separator nil)
		     (ps-print-color-p nil)
		     (ps-left-header (list 'org-agenda-write-buffer-name))
		     (ps-number-of-columns 1)
		     (ps-paper-type 'collinsorganiser)
		     (ps-left-margin (* (/ 1 2.54) 72))
		     (ps-right-margin (* (/ 1 2.54) 72))
		     (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
		    ,(funcall filename-to-export-views "agenda/collins" '("ps"))
		    )
		   ("p" "Todo items with persistent tags"
		    tags-tree ,select-persistent-tags)
		   ("u" "Todo items without persistent tags"
		    tags-tree ,deselect-persistent-tags)
		   ("A" "Agenda View" .
		    ,(funcall agenda-view
			      '((org-agenda-span 1)
				(ps-print-color-p nil)
				(ps-left-header (list 'org-agenda-write-buffer-name))
				(ps-number-of-columns 1)
				(org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
				)
			      "agenda/agenda"
			      '("ps" "html")))

		   ("Y" "Year Agenda View (ICS)" agenda ""
		    ((org-agenda-span 366)
		     (org-agenda-remove-tags t)
		     (ps-number-of-columns 1)
		     (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
		     (org-agenda-skip-function nil)
		     )

		    ,(funcall filename-to-export-views
			      "agenda/agenda"
			      '("ics"))
		    )

		   ("O" "Other tags (EXPORT)" .
		    ,(funcall other-tags-view
			      '((ps-number-of-columns 1)
				(ps-print-color-p nil)
				(ps-left-header (list 'org-agenda-write-buffer-name))
				(org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			      "agenda/tag/OTHER"
			      '("ps" "html")))
		   ("S" "Stuck projects (EXPORT)" .
		    ,(funcall stuck-view
			      '((ps-number-of-columns 1)
				(ps-left-header (list 'org-agenda-write-buffer-name))
				(ps-print-color-p nil)
				(org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			      "agenda/stuck"
			      '("ps" "html")))
		   ("P" . "Todo items with specific persistent tag") ; See tag-persistent-agenda-commands below
		   ("X" "Tasks to Archive" tags ,deselect-persistent-tags
		    ((org-agenda-overriding-header "Tasks to Archive")
		     (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		     (org-tags-match-list-sublevels nil))
		    )
		   )
		 (funcall tag-persistent-agenda-commands
			  '((org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
			    (ps-print-color-p nil)
			    (ps-number-of-columns 1)
			    (ps-left-header (list 'org-agenda-write-buffer-name))
			    (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			  "agenda/tag/"
			  '("ps" "html"))
		 ))
	  ))

    #+END_SRC
*** Agenda Window
    Take up current window when called.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-window-setup 'current-window)
    #+END_SRC

** Stuck Projects
   1. Match projects as
      1. Any LEVEL 1 headline
      2. Do not match completed headlines
      3. Do not match items tagged with NOARCHIVE
      3. Do not match items tagged with DOC; documentation-only
   2. Non-stuck projects have headlines which contain a NEXT todo-keyword.
   3. Non-stuck projects have headlines which may contain a specific tag; but not
      in this case.
   4. Non-stuck projects are identified if the special word IGNORE is matched
      anywhere.
   #+BEGIN_SRC emacs-lisp
     (setq org-stuck-projects
	   '("-DOC-NOARCHIVE+LEVEL=1/-DONE" ("NEXT") nil "\\<IGNORE\\>"))
   #+END_SRC

** Priorities
*** Keys
    Use "C-c ," to quickly set priorities.
    Only "," is required in agenda.

*** Default Priority Values
    Priorities are assigned A,B,C,D (E,F). B being the default.
    I'm particularly inspired by the Eisenhower Matrix and Must/Should/Nice todos.
    For reference, see the table below. Typically, one should attempt to accomplish
    as many B's in a day as possible; while also taking regular breaks.
    If you have nothing left todo, D's are pleasant enough.

    | PRIORITY   | NOT IMPORTANT | IMPORTANT  |
    |------------+---------------+------------|
    | NOT URGENT | D - PLEASANT  | B - SHOULD |
    |------------+---------------+------------|
    | URGENT     | C - NICE      | A - MUST   |
    |------------+---------------+------------|

    So.. one way to describe my priorities, would be...
    #+BEGIN_EXAMPLE
    #+PRIORITIES: C A F .
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (setq org-default-priority ?D)
      (setq org-highest-priority ?A)
      (setq org-lowest-priority ?F)
    #+END_SRC

** Dependencies
   Dependency settings.
   This allows for task blocking/etc.
   #+BEGIN_SRC emacs-lisp
     (setq org-enforce-todo-dependencies t)
     (setq org-agenda-dim-blocked-tasks t)
     (setq org-enforce-todo-checkbox-dependencies nil)
   #+END_SRC

