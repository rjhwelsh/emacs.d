#+TITLE: Getting Things Done with Org-mode
#+AUTHOR: Roger J. H. Welsh
#+EMAIL: rjhwelsh@posteo.net
#+PROPERTY: header-args :results silent
#+STARTUP: content

#+begin_src emacs-lisp
  (rjh/use "org/org:private")
#+end_src


* Agenda
** Keywords
*** Function to extract todo keywords from variable
    #+begin_src emacs-lisp
      (defun org-todo-keywords-extract (&optional todo-keywords) 
	"Extract todo keywords from the `org-todo-keywords' variable."
	(mapcar 
	 (lambda (sequence)
	   (let* ((keywords (cdr sequence)))
	     (org-remove-keyword-keys keywords)
	     ))
	 (or todo-keywords org-todo-keywords)))
    #+end_src

*** Todo item workflow
   Workflow states have been taken from gjstein/sachachua.
   See gjstein [[http://cachestocaches.com/2016/9/my-workflow-org-agenda/#][here]].
   See sachachua [[https://sachachua.com/blog/2007/12/emacs-getting-things-done-with-org-basic/][here]].

   - todo :: Indicate tasks / projects which need to get done
   - next :: Tasks which are being done "next" within a particular project
   - started :: Tasks which have been started
   - waiting :: Tasks waiting on someone else.
     Log notes on what this is waiting on.
   - done :: Completed task

   For below; make the following notes:
   + Expressions may be a "sequence" or "type" ; "type" goes straight to DONE
     after completion. Sequences rotate through all keywords.
   + TODO = the todo keyword
   + (t) = the fast key shortcut
   + ! means LOG timestamp when changing *TO* state.
   + @ means LOG note when changing *TO* state.
   + X/Y means perform X when changing *TO* state, and Y when changing *FROM* state.
   #+BEGIN_SRC emacs-lisp
     (setq org-todo-keywords
	   '((sequence "TODO(t)" "NEXT(n)" "STARTED(s!)" "WAITING(w!/!)" "|" "DONE(d!)")
	     ))
   #+END_SRC
   + org-log-into-drawer LOGS everything into a hidden drawer, so everything looks cleaner.
   #+BEGIN_SRC emacs-lisp
     (setq org-log-into-drawer t) ;;LOGBOOK
   #+END_SRC

   For group projects, put this at the top of the project line for custom keywords.
   #+BEGIN_EXAMPLE
   #+TYP_TODO: @MYNAME(m) @NAME1(1) @NAME2(2) | DONE(d)
   #+END_EXAMPLE
*** GTD workflow 
These keywords capture the GTD state of "projects".
#+begin_src emacs-lisp
  (setq org-gtd-workflow
      ;; The next stage for this project is ... 
	'(sequence
	  "COLLECT(1!)" ;; Thoughts need to be collected for this project (synonym: brainstorm)
	  "CLARIFY(2!)" ;; Current thoughts need to clarified into what things mean, and what to do.
	  "ORGANIZE(3!)" ;; The results need to be organized, shifted into the right bucket
	;; Scheduled/deadline/timed actions
	;; NEXT actions
	;; Waiting actions
	;; Project plans, REFILE to alternative project?
	;; Reference material
	;; Someday/Maybe, hold for review
	;; Trash
	  "REVIEW(4!)"  ;; Gather, and process stuff, review system, update your lists, get clean/clear/current complete
	;; Everything is organized here, but not prioritized/reviewed
	;; Review is the final check before committing a project to action
	  "DO(5!)"      ;; Stuff ready for action
	;; Everything is stream-lined and ready to go for this task
	  "|"
	  ))

  ;; Append to org-todo-keywords
  (setq org-todo-keywords (append org-todo-keywords (list org-gtd-workflow)))

  ;; Plain keywords for agenda view construction
  (setq org-gtd-workflow-1 (car (org-todo-keywords-extract (list (remove "|" org-gtd-workflow)))))
#+end_src
** Stuck Projects
   1. Match projects as
      1. Any LEVEL 1 headline
      2. Do not match completed headlines
      3. Do not match items tagged with NOARCHIVE
      3. Do not match items tagged with DOC; documentation-only
   2. Non-stuck projects have headlines which contain a NEXT todo-keyword.
   3. Non-stuck projects have headlines which may contain a specific tag; but not
      in this case.
   4. Non-stuck projects are identified if the special word IGNORE is matched
      anywhere.
   #+BEGIN_SRC emacs-lisp
     (setq org-stuck-projects
	   '("-DOC-NOARCHIVE+LEVEL>=1/-DONE" 
	     ("NEXT")
	     nil 
	     "\\<IGNORE\\>"
	     ))
   #+END_SRC

** Tags
   Tags represent environmental conditions before a task can be undertaken.
   Tasks should be organized by a hierarchy of projects and sub-projects.
   Projects are prioritized, tags develop views for batch processing tasks.

   IF <tag> THEN <task>
   IF <condition> THEN <task>
   IF <tag1> AND <tag2> AND ... THEN <task>

   Tags should not be inherited by sub-tasks.
   Sub-tasks should differentiate work dependencies only.

*** Default tags
    See =org-tag-alist= for more details.
    #+BEGIN_SRC emacs-lisp
      (setq org-tag-alist '())
    #+END_SRC
*** Tag inheritance
    Inherit all tags.
    #+BEGIN_SRC emacs-lisp
      (setq org-use-tag-inheritance t)
    #+END_SRC

    This will exclude all tags from =org-tag-persistent-alist= from being inherited.
    #+BEGIN_SRC emacs-lisp
      (setq org-tags-exclude-from-inheritance (mapcar 'car org-tag-persistent-alist))
    #+END_SRC

*** Functions to expire tags
    Expiration tags are temporary tags for grouping TODO items in a short-term
    meaningful way. These functions quickly expunge these temporary tags in bulk, to
    facilitate better short-term planning and turnover.

    Expiration tags.
    #+BEGIN_SRC emacs-lisp
      (defcustom rjh/org-tags-expiration-tags
	(mapcar 'car org-tag-persistent-alist)
	"Org-mode tags which can be removed quickly, with org-tags-expire."
	;; The rest of this is copied from org-tag-persistent-alist
	:group 'org-tags
	:type '(repeat
		(choice
		 (cons :tag "Tag with key"
		       (string    :tag "Tag name")
		       (character :tag "Access char"))
		 (list :tag "Tag" (string :tag "Tag name"))
		 (const :tag "Start radio group" (:startgroup))
		 (const :tag "Start tag group, non distinct" (:startgrouptag))
		 (const :tag "Group tags delimiter" (:grouptags))
		 (const :tag "End radio group" (:endgroup))
		 (const :tag "End tag group, non distinct" (:endgrouptag))
		 (const :tag "New line" (:newline)))))
    #+END_SRC

    Generic interactive function.
    - Will expire tags for current item
    - Will expire tags for entire buffer when called with a prefix.
    #+BEGIN_SRC emacs-lisp
      (defun rjh/org-tags-expire (ARG)
	"Expires all expiration tags.
      PREFIXARG = Expire tags in buffer if non-nil"
	(interactive "p")
	(if (>= ARG 4)
	    (rjh/org-tags-expire-buffer)
	  (if (org-region-active-p)
	      (call-interactively 'rjh/org-tags-expire-region)
	    (rjh/org-tags-expire-entry))))
    #+END_SRC

**** org-mode
     These provide functions for removing expiration-tags in the current
     =org-mode= buffer.

     Tag expiration for headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-headline ( expiration-tags )
	 "Removes all expiration tags from headline."
	 (let ((newtagslist (org-get-tags nil t)))
	   (unless (null newtagslist)
	     (dolist (element expiration-tags)
	       (when (member element newtagslist)
		 (setq newtagslist (delete element newtagslist))))
	     (org-set-tags newtagslist)
	     (org-reveal))))
     #+END_SRC

     Tag expiration for entry (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-entry ()
	 "Expires all expiration tags in current entry."
	 (interactive)
	 (save-excursion
	   (org-back-to-heading 't)
	   (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags)))
     #+END_SRC

     Tags expiration for buffer (interactive).
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-buffer ()
	 "Expires all expiration tags in current buffer.
       Includes invisible heading lines."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (outline-next-heading)
	     (rjh/org-tags-expire-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Tags expiration for a region of an org buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-region (start end)
	 "Expires all expiration tags in current region."
	 (interactive "r")
	 (dolist (element rjh/org-tags-expiration-tags)
	   (org-change-tag-in-region start end element 'off)))
     #+END_SRC

**** org-agenda
     These are functions to remove expiration tags in the =org-agenda=.

     Tag expiration for an agenda headline.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-headline ( expiration-tags )
	 "Removes all expiration tags from an AGENDA headline."
	 (dolist (element expiration-tags)
	   (org-agenda-set-tags element 'off)))
     #+END_SRC

     Tag expiration for an agenda buffer.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda-buffer ()
	 "Removes all expiration tags from an AGENDA buffer."
	 (interactive)
	 (save-excursion
	   (goto-char (point-min))
	   (while (and (org-agenda-next-item 1)
		       (next-single-property-change (point-at-eol) 'org-marker))
	     (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags))))
     #+END_SRC

     Generic interactive agenda function.
     - Will expire selected headlines
     - Will expire whole agenda buffer with prefix.
     #+BEGIN_SRC emacs-lisp
       (defun rjh/org-tags-expire-agenda (ARG)
	 "Expires tags in org-agenda view."
	 (interactive "p")
	 (save-excursion
	   (if (>= ARG 4)
	       (rjh/org-tags-expire-agenda-buffer)
	     (if (org-region-active-p)
		 (call-interactively 'rjh/org-tags-expire-region)
	       (rjh/org-tags-expire-agenda-headline rjh/org-tags-expiration-tags)))))
     #+END_SRC

*** Column
    Set tag column formatting relative to headline.
    #+begin_src emacs-lisp
      (setq org-tags-column 0)
    #+end_src

    Set tag column formatting for agenda.
    #+begin_src emacs-lisp
      (setq org-agenda-tags-column -80)
    #+end_src
** Priorities
*** Keys
    Use "C-c ," to quickly set priorities.
    Only "," is required in agenda.

*** Default Priority Values
    Priorities are assigned A,B,C,D (E,F). B being the default.
    I'm particularly inspired by the Eisenhower Matrix and Must/Should/Nice todos.
    For reference, see the table below. Typically, one should attempt to accomplish
    as many B's in a day as possible; while also taking regular breaks.
    If you have nothing left todo, D's are pleasant enough.

    | PRIORITY   | NOT IMPORTANT | IMPORTANT  |
    |------------+---------------+------------|
    | NOT URGENT | D - PLEASANT  | B - SHOULD |
    |------------+---------------+------------|
    | URGENT     | C - NICE      | A - MUST   |
    |------------+---------------+------------|

    So.. one way to describe my priorities, would be...
    #+BEGIN_EXAMPLE
    #+PRIORITIES: C A F .
    #+END_EXAMPLE

    #+BEGIN_SRC emacs-lisp
      (setq org-default-priority ?D)
      (setq org-highest-priority ?A)
      (setq org-lowest-priority ?F)
    #+END_SRC

** Dependencies
   Dependency settings.
   This allows for task blocking/etc.
   #+BEGIN_SRC emacs-lisp
     (setq org-enforce-todo-dependencies t)
     (setq org-agenda-dim-blocked-tasks t)
     (setq org-enforce-todo-checkbox-dependencies nil)
   #+END_SRC

** Views
*** Agenda settings
**** Default agenda time span
    Set default agenda span for a single day.
    #+begin_src emacs-lisp
      (setq org-agenda-span 1)
    #+end_src
**** Use current window
   Take up current window when called.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-window-setup 'current-window)
    #+END_SRC

**** Include diary entries
     #+begin_src emacs-lisp
       (setq org-agenda-include-diary t)
     #+end_src
**** Agenda prefix format
     Prefix format
     #+begin_src emacs-lisp
       (setq org-agenda-prefix-format
	     '((agenda . "%?-12t%?-12s ")
	       (todo .   "%12:c ")
	       (tags .   "%12:c ")
	       (search . "%12:c%b "))
	     )
     #+end_src
**** Limits
     Limit the number of results in the agenda. 
#+begin_src emacs-lisp
  (setq org-agenda-max-entries 1000)
#+end_src
*** Agenda Files List
    Store the list of agenda files in ...
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files "~/.emacs.d/agenda-files" )
    #+END_SRC
*** Sorting Strategy
    Sorting strategy.
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-sorting-strategy
	    '((agenda time-up deadline-up scheduled-up todo-state-down category-keep              priority-down effort-up tag-up)
	      (todo           todo-state-down          priority-down   effort-up                  deadline-up category-keep tag-up)
	      (tags                                    todo-state-down category-keep              deadline-up priority-down effort-up tag-up)
	      (search         deadline-up              todo-state-down category-keep              priority-down effort-up tag-up)))
    #+END_SRC
*** Agenda Skip Functions
**** Org-agenda-skip-function
     Use =org-agenda-skip-function= option to define a function to skip entries. 
     - When the function returns nil, the entry will be skipped
     - Otherwise the function must return a position from where the search should continue
#+begin_example el
(let (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
#+end_example

**** Skip non archive-able tasks
     A function for skipping non-archive-able tasks in the agenda-view from Bernt Hansen.
     #+BEGIN_SRC emacs-lisp
       (defun bh/skip-non-archivable-tasks ()
	 "Skip trees that are not available for archiving"
	 (save-restriction
	   (widen)
	   (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		 (subtree-end (save-excursion (org-end-of-subtree t))))
	     ;; Entry has a todo keyword ?
	     (if (member (org-get-todo-state) org-todo-keywords-1)
	     ;; Entry has a completed todo keyword ?
		 (if (member (org-get-todo-state) org-done-keywords)
		     (let* ((daynr (string-to-number (format-time-string "%d" (current-time))))
			    (a-month-ago (* 60 60 24 (+ daynr 1)))
			    (last-month (format-time-string "%Y-%m-" (time-subtract (current-time) (seconds-to-time a-month-ago))))
			    (this-month (format-time-string "%Y-%m-" (current-time)))
		            ;; Subtree contains timestamp for this month or last month
			    (subtree-is-current (save-excursion
						  (forward-line 1)
						  (and ( < (point) subtree-end) ; This line is causing a bracket mismatch
						       (re-search-forward (concat last-month "\\|" this-month) subtree-end t)))))
		       (if subtree-is-current
			   subtree-end ; Has a date in this month or last month, skip it
			 nil))  ; nil = do not skip
		   (or subtree-end (point-max)))
	       next-headline))))
     #+END_SRC

**** Skip entries that are blocked
     https://emacs.stackexchange.com/questions/14724/emacs-org-mode-how-to-make-agenda-views-of-blocked-parent-tasks
     A function that skips any task that is blocked (because of some dependency). 
     #+begin_src emacs-lisp
       (defun org-agenda-skip-entry-if-blocked ()
	 "Skip entry if it is blocked."
	 (let ((next-headline 
		(save-excursion
		  (or (outline-next-heading) (point-max))))
	       ;; Do not skip items blocked by checkboxes
	       (org-enforce-todo-checkbox-dependencies nil))
	   (if (org-entry-blocked-p) next-headline)))
     #+end_src

**** Skip entries that have a particular file path
A function that skips entries based on the location of the file.
#+begin_src emacs-lisp
  (defun org-agenda-skip-entry-if-file-path (regexp &optional inverse)
    "Skip entry if it is in a file on path."
    (let* ((path (buffer-file-name))
	   (match-p (string-match regexp path)))
      (if match-p (point-max))
      ))
#+end_src

**** Skip headline if it matches a regexp
     #+begin_src emacs-lisp
       (defun org-agenda-skip-if-regexp (skip-re)
	 "Skip headline if regexp matches the headline"
	 (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		(subtree-end (save-excursion (org-end-of-subtree t)))
		(current-level (org-current-level)) 
		(match-p 
		 (save-excursion
		   (let ((case-fold-search nil)
			 (eol (save-excursion (org-end-of-line nil) (point))))
		     (re-search-forward 
		      skip-re eol t)))))
	   (if match-p next-headline)))
     #+end_src

**** Skip sub-tree functions 
     These sub-tree skipping functions are derived from =org-agenda-list-stuck-projects=.
***** Skip sub-tree based on regexp match
#+begin_src emacs-lisp
  (defun org-agenda-skip-subtree-if-regexp (skip-re)
    "Skip subtree if regexp matches anywhere inside subtree, not including current headline."
    ;; Skip entry if `org-agenda-skip-regexp' matches anywhere
    ;; in the subtree.
    (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
	   (subtree-end (save-excursion (org-end-of-subtree t)))
	   (current-level (org-current-level)) 
	   (match-p 
	    (save-restriction
	      (widen)
	      (save-excursion
		(let ((case-fold-search nil))
		  (progn
		    ;; skip over current headline
		    (org-end-of-line nil)
		    (if (< (point) subtree-end)
			    (re-search-forward
			     skip-re subtree-end t))
		    ))))))
      (if 
	  (or 
	   (and invert (not match-p))
	   (and (not invert) match-p))
	  next-headline
	)))
  #+end_src
***** Skip sub-tree based on tags present
#+begin_src emacs-lisp
  (defun org-agenda-skip-subtree-if-tags (tags)
    "Skip subtree if any of the tags match.
  Tags is a list of tags"
    (let* ((tags-re (cond ((null tags) nil)
			  ((member "*" tags) org-tag-line-re)
			  (tags
			   (let ((other-tags (format "\\(?:%s:\\)*" org-tag-re)))
			     (concat org-outline-regexp-bol
				     ".*?[ \t]:"
				     other-tags
				     (regexp-opt tags t)
				     ":" other-tags "[ \t]*$")))
			  (t nil)))
	   (re-list (delq nil (list tags-re)))
	   (skip-re
	    (if (null re-list)
		(error "Missing information to identify unstuck projects")
	      (mapconcat #'identity re-list "\\|"))))
      (org-agenda-skip-subtree-if-regexp skip-re)))
  #+end_src
***** Skip sub-tree based on todo keywords present
#+begin_src emacs-lisp
  (defun org-agenda-skip-subtree-if-todo (todo)
    "Skip subtree if any of the todo keywords match.
  todo is a list of todo keywords"
    (let* ((todo-wds
	    (if (not (member "*" todo)) todo
	      (org-agenda-prepare-buffers (org-agenda-files nil 'ifmode))
	      (org-delete-all org-done-keywords-for-agenda
			      (copy-sequence org-todo-keywords-for-agenda))))
	   (todo-re (and todo
			 (format "^\\*+[ \t]+\\(%s\\)\\>"
				 (mapconcat #'identity todo-wds "\\|"))))
	   (re-list (delq nil (list todo-re)))
	   (skip-re
	    (if (null re-list)
		(error "Missing information to identify unstuck projects")
	      (mapconcat #'identity re-list "\\|"))))
      (org-agenda-skip-subtree-if-regexp skip-re)))
  #+end_src

**** Skip if immediate parent/child nodes match
***** Skip headline if immediate children would be skipped
      #+begin_src emacs-lisp
	(defun org-agenda-skip-if-children (skip-function &rest skip-func-args )
	  "Skip headline if any immediate children match the SKIP-FUNCTION and SKIP-FUNC-ARGS"
	  (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		 (subtree-end (save-excursion (org-end-of-subtree t)))
		 (current-level (org-current-level)) 
		 (match-p 
		  (save-restriction
		    (widen)
		    (save-excursion
		      (progn
			;; skip over current headline
			(org-end-of-line nil)
			;; Only match immediate children headlines with skip-function
			(let ((retval nil))
			  (cl-loop
			   ;; Return value or past end of subtree
			   (if 
			       (or retval
				   (>= (point) subtree-end))
			       (return retval))
			   (if 
			       (outline-next-heading)
			       ;; Skip unless exactly 1 level deeper than current headline
			       (if (= (org-current-level) (1+ current-level))
				   (setq retval (apply skip-function skip-func-args)))
			     ;; No more headings.. return
			     (return retval))
			   )))))))
	    (if match-p next-headline)))
      #+end_src
***** Skip headline if immediate parent would be skipped
      #+begin_src emacs-lisp
	(defun org-agenda-skip-if-parent (skip-function &rest skip-func-args)
	  "Skip headline if any immediate parents match the SKIP-FUNCTION and SKIP-FUNC-ARGS"
	  (let* ((prev-headline (save-excursion (or (outline-previous-heading) (point-min))))
		 (next-headline (save-excursion (or (outline-next-heading) (point-max))))
		 (subtree-end (save-excursion (org-end-of-subtree t)))
		 (current-level (org-current-level)) 
		 (match-p 
		  (save-restriction
		    (widen)
		    (save-excursion
		      (progn
			;; Return nil if no parents
			(when (> (org-current-level) 1)
			  ;; Move to parent heading
			  (outline-up-heading 1)
			  ;; Apply skip function to immediate parent only
			  (apply skip-function skip-func-args))
			)))))
	    (if match-p next-headline)))
      #+end_src
**** Invert skip function
     #+begin_src emacs-lisp
       (defun org-agenda-skip-invert (skip-function &rest skip-func-args)
	 "Skip headline if the SKIP-FUNCTION with SKIP-FUNC-ARGS returns nil"
	 (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		(match-p (apply skip-function skip-func-args)))
	   (if (not match-p) next-headline)))
     #+end_src
**** Org element API skipping functions
***** Skip element based on regexp match of property
     #+begin_src emacs-lisp
       (defun org-agenda-skip-element-if-property-regexp (prop skip-re &optional invert)
	 "Skip headline if regexp matches with the specified property; property must reference a string-value.
	INVERT; if t, inverts the match"
	 (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
		(match-p 
		 (let ((case-fold-search nil))
		   (string-match 
		    skip-re
		    (org-element-property prop (org-element-at-point)))))
		)
	   (if 
	       (or 
		(and invert (not match-p))
		(and (not invert) match-p))
	       next-headline
	     )))
     #+end_src
*** Global skip function
    #+begin_src emacs-lisp
      (setq org-agenda-skip-function-global 
	    '(or 
	      ;; Skip DONE tasks
	      (org-agenda-skip-entry-if 'todo 'done) 
	      ;; Skip BLOCKED tasks
	      (org-agenda-skip-entry-if-blocked)
	      ;; Skip file PATHs
	      (org-agenda-skip-invert
	       'org-agenda-skip-entry-if-file-path "1action")
	      ))
    #+end_src

    Standard function for skipping entries
    - =(org-agenda-skip-entry-if &rest CONDITIONS)= :: Skip if any of the CONDITIONS
      are true
      - ='scheduled= :: Entry has a scheduled time.
      - ='deadline= :: Entry has a deadline.
      - ='timestamp= :: Entry has any timestamp (including deadline or scheduled)
      - ='todo= :: Entry todo keyword matches (accepts as argument a list of todo keywords)
	- ='("TODO" "DONE")= :: Matches any of TODO or DONE.
	- ='done= :: Matches keyword class 'done
	- ='todo= :: Matches keyword class 'todo
*** Custom Agenda Views
    NB =`= backquote allows evaluation of selected element in the quoted list.
    =,= is used to indicate items to be evaluated.

    Sparse trees cannot be used in assembled views; they operate on the current
    buffer only.
 
    ps-print is required for exporting views
    #+begin_src emacs-lisp
      (require 'ps-print)
    #+end_src
**** Clear org-agenda-custom-commands list
    Set current custom agenda views to an empty list.
    #+begin_src emacs-lisp
    (setq org-agenda-custom-commands '())
    #+end_src
**** Provide interface for export filename
    Standard export location for org-agenda-views
#+begin_src emacs-lisp
  (defun org-agenda-filename-to-export-views (filename exts)
    "Returns a standard location to export agenda views to"
    (progn 
      (mapcar
       (lambda (x)
	 (expand-file-name
	  (concat filename "." x)
	  org-directory
	  ))
       exts)
      )
    )
#+end_src

*** Custom search terms
**** Search term for an item with any persistent tag attached
    Select todo items with any persistent tag. *p*
    #+begin_src emacs-lisp
      ;; Search for any persistent-tags
      (setq org-agenda-select-persistent-tags
	    (apply 'concat
		   (cdr
		    (apply 'append
			   (mapcar
			    (lambda (tag)
			      (list "|" (car tag))
			      )
			    org-tag-persistent-alist))
		    )))
    #+end_src
**** Search term for anything *without* a persistent tag
    #+begin_src emacs-lisp
      ;; Search for anything without a persistent tag
      (setq org-agenda-deselect-persistent-tags
	    (apply
	     'concat
	     (mapcar
	      (lambda (tag)
		(concat "-" (car tag))
		)
	      org-tag-persistent-alist)
	     )
	    )
    #+end_src
*** Todo search views
**** Make a list of all projects
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands
		    '("A" "List of Active Projects" tags 
		      "+LEVEL>=1"
		      ((org-agenda-overriding-header "List of projects")
		       ;; Skip functions
		       (org-agenda-skip-function-global nil) 
		       ;; DO NOT skip entry unless it has no todo children
		       ;; Or SKIP if it is a todo item, LEVEL>1
		       (org-agenda-skip-function 
			'(or 
			  (org-agenda-skip-invert
			  'org-agenda-skip-if-children 
			  'org-agenda-skip-entry-if
			  'todo 'todo)
			  (and 
			   (> (org-current-level) 1)
			   (org-agenda-skip-entry-if 'nottodo org-gtd-workflow-1)
			   )))
		       ;; Match sublevels in tag search
		       (org-tags-match-list-sublevels t)
		       (org-use-tag-inheritance nil)
		       ;; Sort by priority, then by category (as in org-agenda-files)
		       (org-agenda-sorting-strategy '((tags priority-down category-keep)))
		       ;; Show full breadcrumbs for each project
		       (org-agenda-prefix-format '((tags . "%12:c %b")))
		       ;; Other options
		       (org-agenda-tags-todo-honor-ignore-options nil)
		       (org-agenda-dim-blocked-tasks nil)
		       )))
     #+end_src  

**** Match any todo item which can be archived
 Tasks to Archive
 This relies on the ='bh/skip-non-archivable-tasks= skip function.
 #+begin_src emacs-lisp
   (add-to-list 'org-agenda-custom-commands
		'("X" "Tasks to Archive" todo ""
		  ;; tags ,deselect-persistent-tags
		  ((org-agenda-overriding-header "Tasks to Archive")
		   (org-agenda-skip-function 'bh/skip-non-archivable-tasks)
		   (org-tags-match-list-sublevels nil))
		  ))
 #+end_src
*** Tag search views
**** Persistent Tags View Generator
     This function generates a list of =org-agenda-custom-commands= for each tag in =org-tag-persistent-alist=.
     #+begin_src emacs-lisp
       ;; Generator for persistent-tag-agenda-views
       (defun org-agenda-tag-persistent-agenda-views (&optional settings filename exts)
	 "Generates a list of custom-commands for org-agenda to display persistent-tags"
	 (progn
	   (mapcar
	    (lambda (tag)
	      `(,(car tag) . (tags
			      ,(concat "+" (car tag))
			      ,settings
			      ,(org-agenda-filename-to-export-views (concat filename (car tag)) exts)
			      )))
	    org-tag-persistent-alist)))
     #+end_src
**** Add a view for each persistent tag
    *Persistent tags*
    Select todo items with a specific persistent tag. *P*
    The first letter of each tag is used after the prefix.
     #+begin_src emacs-lisp
       ;; Add a custom view for each persistent tag under a prefix
       (let* (
	      (persistent-tag-prefix-key "P")
	      (tag-persistent-agenda-commands
	       (lambda (&optional settings filename exts)
		 (mapcar
		  (lambda (tag_arr)
		    (let ((tag (car tag_arr)))
		      (append
		       `(
			 ,(concat persistent-tag-prefix-key (substring tag 0 1)) ; PREFIX
			 ,(format "Headlines with TAGS match: %s" tag)) ; DESCRIPTION
		       (cdr (assoc tag (org-agenda-tag-persistent-agenda-views settings filename exts)))
		       )
		      ))
		  org-tag-persistent-alist
		  )))
	      )
	 (setq org-agenda-custom-commands
	       (append 
		org-agenda-custom-commands
		`((,persistent-tag-prefix-key . "Todo items with specific persistent tag")) ; Prefix command
		(funcall tag-persistent-agenda-commands
			 '((org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
			   (ps-print-color-p nil)
			   (ps-number-of-columns 1)
			   (ps-left-header (list 'org-agenda-write-buffer-name))
			   (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			 "agenda/tag/"
			 '("ps" "html"))
		)))
     #+end_src

**** Add a view for remaining todo items without persistent tags
    #+begin_src emacs-lisp
      ;; Export view for untagged tasks
      (add-to-list 'org-agenda-custom-commands
		   `("O" "Other tags" .
		     (tags-todo
		      ,org-agenda-deselect-persistent-tags
		      ,(append
			'((org-agenda-overriding-header "Remaining TODO items:")
			  (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'todo 'done)))
			'((ps-number-of-columns 1)
			  (ps-print-color-p nil)
			  (ps-left-header (list 'org-agenda-write-buffer-name))
			  (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			)
		      ,(org-agenda-filename-to-export-views "agenda/tag/OTHER" '("ps" "html"))
		      )))
    #+end_src
*** Sparse search of current buffer
    The manual way to create a sparse tree of the current buffer is to use the =org-sparse-tree= command. 
    The default keys are =C-c /= to manually create a sparse tree. 
    Possible tree types include =occur-tree=, =tags-tree=, or =todo-tree=.

**** Sparse-tree prefix
     #+begin_src emacs-lisp
       (setq org-agenda-sparse-prefix "\\") ;; \ for creating a sparse tree in the current Buffer
       (add-to-list 'org-agenda-custom-commands
		    `(,org-agenda-sparse-prefix . "Sparse-tree search of current buffer"))
     #+end_src

**** Tags-tree
***** Sparse tree of *any persistent tags* 
     #+begin_src emacs-lisp
       ;; Tags tree
       (add-to-list 'org-agenda-custom-commands
		    `(,(concat org-agenda-sparse-prefix "p") 
		      "Todo items with persistent tags"
		      tags-tree ,org-agenda-select-persistent-tags)
		    )
     #+end_src
***** Sparse tree of anything *without* a persistent tag
     Select todo items without any persistent tags. *u*
     #+begin_src emacs-lisp
       ;; Tags-tree 
       (add-to-list 'org-agenda-custom-commands 
		    `(
		      ,(concat org-agenda-sparse-prefix "u") 
		      "Todo items without persistent tags"
		      tags-tree ,org-agenda-deselect-persistent-tags)
		    )
     #+end_src
*** Export views
The custom agenda views are explicitly for exporting data to other applications. 
Their actual functionality is covered by default views, or other existing views. 
**** Export view prefix
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands '("E" . "Export-only views"))
     #+end_src

**** Agenda view (EXPORT)
 "Agenda view"
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands
		    `("EA" "Agenda View (EXPORT)" .
		      (agenda ""
		       (
			 (org-agenda-skip-function nil)
			 (org-agenda-span 1)
			 (ps-print-color-p nil)
			 (ps-left-header (list 'org-agenda-write-buffer-name))
			 (ps-number-of-columns 1)
			 (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
			 )
		       ,(org-agenda-filename-to-export-views "agenda/agenda" '("ps" "html"))
		       )))
     #+end_src
**** Year Calendar File (EXPORT)
 "Year Agenda View (ICS)"
     #+begin_src emacs-lisp
       (add-to-list 'org-agenda-custom-commands
		    `("EY" "Year Agenda View (EXPORT)" agenda ""
		      ((org-agenda-span 366)
		       (org-agenda-remove-tags t)
		       (ps-number-of-columns 1)
		       (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
		       ;; Exclude actual calendar for export
		       (org-agenda-skip-function '(org-agenda-skip-entry-if-file-path "calendar.org")) 
		       ) 
		      ,(org-agenda-filename-to-export-views
			"agenda/agenda"
			'("ics"))))
     #+end_src
**** Stuck projects (EXPORT)
 Stuck projects (EXPORT)
 #+begin_src emacs-lisp
   (add-to-list 'org-agenda-custom-commands
		  `("ES" "Stuck projects (EXPORT)" .
		    (stuck ""
			   ((ps-number-of-columns 1)
			    (ps-left-header (list 'org-agenda-write-buffer-name))
			    (ps-print-color-p nil)
			    (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
			   ,(org-agenda-filename-to-export-views 
			     "agenda/stuck"
			     '("ps" "html")))))
 #+end_src
*** Combination view
**** Full view generator
    #+begin_src emacs-lisp
      ;; Define full-view compilation
      (defun org-agenda-full-view nil
       "Compilation overview generator for org-agenda-custom-commands."
	(append
	 `((agenda ""))
	   (mapcar 'cdr
		   (org-agenda-tag-persistent-agenda-views
		    (append
		     '(
		       (org-agenda-skip-function '(org-agenda-skip-entry-if 'timestamp 'nottodo 'todo))
		       )
		     )))
	   `((tags-todo ,org-agenda-deselect-persistent-tags)
	     (stuck ""))
	     ))
    #+end_src
**** "Active view"
    #+begin_src emacs-lisp
      ;; Active view
      (add-to-list 'org-agenda-custom-commands
		   `("En" "Active View"
		     ,(org-agenda-full-view)
		     ((ps-number-of-columns 1)
		      (ps-left-header (list 'org-agenda-write-buffer-name))
		      (ps-print-color-p nil)
		      (ps-landscape-mode t))
		     ,(org-agenda-filename-to-export-views "agenda/full" '("ps" "html"))
		     ))
    #+end_src
**** "Summary view"
    #+begin_src emacs-lisp
      ;; Summary view
      (add-to-list 'org-agenda-custom-commands
		   (let ((summary-side-margin (* (/ 1 2.54) 72))
			 (summary-border-file "~/.emacs.d/ps/summary_border.ps")
			 )
		     `("Es" "Summary View"
		       ,(org-agenda-full-view)
		       ((org-agenda-start-day "+1d")
			 (org-agenda-span 3)
			 (org-agenda-remove-tags t)
			 (org-agenda-block-separator nil)
			 (ps-print-color-p nil)
			 (ps-left-header (list 'org-agenda-write-buffer-name))
			 (ps-paper-type 'collinsorg3colA4)
			 (ps-number-of-columns 3)
			 (ps-print-background-image 
			  '((,summary-border-file ,(- 0 summary-side-margin) ,(- 0 ps-bottom-margin))))
			 (ps-landscape-mode t)
			 (ps-left-margin ,summary-side-margin)
			 (ps-right-margin ,summary-side-margin)
			 (ps-inter-column (* ,summary-side-margin 2))
			 (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c")
			 )
		       ,(org-agenda-filename-to-export-views "agenda/summary" '("ps" "html"))
		       )))
    #+end_src
**** "Organiser view"

    #+begin_src emacs-lisp
      ;; Organiser view
      (add-to-list 'org-agenda-custom-commands
		   `("Eo" "Organiser View"
		     ,(org-agenda-full-view)
		     ((org-agenda-start-day "+1d")
		      (org-agenda-span 3)
		      (org-agenda-remove-tags t)
		      (org-agenda-block-separator nil)
		      (ps-print-color-p nil)
		      (ps-left-header (list 'org-agenda-write-buffer-name))
		      (ps-number-of-columns 1)
		      (ps-paper-type 'collinsorganiser)
		      (ps-left-margin (* (/ 1 2.54) 72))
		      (ps-right-margin (* (/ 1 2.54) 72))
		      (org-agenda-prefix-format "[ ] %?-12t%?-12s%:c"))
		     ,(org-agenda-filename-to-export-views "agenda/collins" '("ps"))
		     ))
    #+end_src


* Hooks
Auto-actions linked to opening the agenda buffer.
** revert any read-only buffers 
   Workaround to undo any changes to read-only files that might happen as a result of the following hooks.
   #+begin_src emacs-lisp
     (defun rjh/org-agenda-revert-read-only-org-buffers ()
       "Reverts all read-only org-buffers"
       (mapcar 
	(lambda (buffer) 
	  (with-current-buffer buffer 
	    (when buffer-read-only (revert-buffer t t t))))
	  (org-buffer-list 'files))
       )
   #+end_src

   #+begin_src emacs-lisp
   (add-hook 'org-agenda-mode-hook 'rjh/org-agenda-revert-read-only-org-buffers)
   #+end_src
** org-id
   Hooks to ensure each org-mode entry has an associated org-id property.

   Create id upon capture.
   #+begin_src emacs-lisp
     (add-hook 'org-capture-prepare-finalize-hook 'org-id-get-create)
   #+end_src

   Create a function to add ids to all headlines in a file, but only if they are an
   agenda buffer.
   #+begin_src emacs-lisp
     (defun rjh/org-add-ids-to-headlines-in-agenda-files ()
       "Add ID properties to all headlines across agenda buffers which do not already have one."
       (interactive)
       (org-map-entries 
	(lambda () 
	  (condition-case-unless-debug  buffer-read-only
	      (org-id-get-create)
	    (error nil)))
	nil 'agenda)
       )
   #+end_src

   Add hook to agenda-mode.
   #+begin_src emacs-lisp
     (add-hook 'org-agenda-mode-hook 'rjh/org-add-ids-to-headlines-in-agenda-files)
   #+end_src
** remove schedule from completed tasks
   Hook to remove schedule timestamps from any completed tasks.

   Function to remove schedule.
   #+begin_src emacs-lisp
     (defun rjh/remove-schedule ()
       (interactive)
       (condition-case-unless-debug buffer-read-only
	   (let ((current-prefix-arg '(4)))
	     (call-interactively 'org-schedule))
      (error nil)
	 ))
   #+end_src

   Function to remove schedule from all agenda entries.
   #+begin_src emacs-lisp
     (defun rjh/remove-schedule-from-completed-tasks ()
       "Remove schedule from completed tasks in agenda buffers"
       (interactive)
       (org-map-entries 'rjh/remove-schedule "TODO=\"DONE\"+SCHEDULED<\"<today>\"" 'agenda
			))
   #+end_src

   Add hook to agenda-mode.
   #+begin_src emacs-lisp
     (add-hook 'org-agenda-mode-hook 'rjh/remove-schedule-from-completed-tasks)
   #+end_src

